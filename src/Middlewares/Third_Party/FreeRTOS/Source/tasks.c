/*
 * FreeRTOS Kernel V10.0.1
 * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/* Standard includes. */
#include <stdlib.h>
#include <string.h>

/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
all the API functions to use the MPU wrappers.  That should only be done when
task.h is included from an application file. */
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"
#include "stack_macros.h"
#include "printf.h"

/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
header files above, but not in this file, in order to generate the correct
privileged Vs unprivileged linkage and placement. */
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */

/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
functions but without including stdio.h here. */
#if (configUSE_STATS_FORMATTING_FUNCTIONS == 1)
/* At the bottom of this file are two optional functions that can be used
to generate human readable text from the raw data generated by the
uxTaskGetSystemState() function.  Note the formatting functions are provided
for convenience only, and are NOT considered part of the kernel. */
#include <stdio.h>
#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */

#if (configUSE_PREEMPTION == 0)
/* If the cooperative scheduler is being used then a yield should not be
performed just because a higher priority task has been woken. */
#define taskYIELD_IF_USING_PREEMPTION()
#else
#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
#endif

/* Values that can be assigned to the ucNotifyState member of the TCB. */
#define taskNOT_WAITING_NOTIFICATION ((uint8_t)0)
#define taskWAITING_NOTIFICATION ((uint8_t)1)
#define taskNOTIFICATION_RECEIVED ((uint8_t)2)

/*
 * The value used to fill the stack of a task when the task is created.  This
 * is used purely for checking the high water mark for tasks.
 */
#define tskSTACK_FILL_BYTE (0xa5U)

/* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
dynamically allocated RAM, in which case when any task is deleted it is known
that both the task's stack and TCB need to be freed.  Sometimes the
FreeRTOSConfig.h settings only allow a task to be created using statically
allocated RAM, in which case when any task is deleted it is known that neither
the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
settings allow a task to be created using either statically or dynamically
allocated RAM, in which case a member of the TCB is used to record whether the
stack and/or TCB were allocated statically or dynamically, so when a task is
deleted the RAM that was allocated dynamically is freed again and no attempt is
made to free the RAM that was allocated statically.
tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
task to be created using either statically or dynamically allocated RAM.  Note
that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
a statically allocated stack and a dynamically allocated TCB.
!!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
changed then the definition of StaticTask_t must also be updated. */
#define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ((configSUPPORT_STATIC_ALLOCATION == 1) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))
#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB ((uint8_t)0)
#define tskSTATICALLY_ALLOCATED_STACK_ONLY ((uint8_t)1)
#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB ((uint8_t)2)

/* If any of the following are set then task stacks are filled with a known
value so the high water mark can be determined.  If none of the following are
set then don't fill the stack so there is no unnecessary dependency on memset. */
#if ((configCHECK_FOR_STACK_OVERFLOW > 1) || (configUSE_TRACE_FACILITY == 1) || (INCLUDE_uxTaskGetStackHighWaterMark == 1))
#define tskSET_NEW_STACKS_TO_KNOWN_VALUE 1
#else
#define tskSET_NEW_STACKS_TO_KNOWN_VALUE 0
#endif

/*
 * Macros used by vListTask to indicate which state a task is in.
 */
#define tskRUNNING_CHAR ('X')
#define tskBLOCKED_CHAR ('B')
#define tskREADY_CHAR ('R')
#define tskDELETED_CHAR ('D')
#define tskSUSPENDED_CHAR ('S')

/*
 * Some kernel aware debuggers require the data the debugger needs access to be
 * global, rather than file scope.
 */
#ifdef portREMOVE_STATIC_QUALIFIER
#define static
#endif

/* The name allocated to the Idle task.  This can be overridden by defining
configIDLE_TASK_NAME in FreeRTOSConfig.h. */
#ifndef configIDLE_TASK_NAME
#define configIDLE_TASK_NAME "IDLE"
#endif

#if (configUSE_PORT_OPTIMISED_TASK_SELECTION == 0)

/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
performed in a generic way that is not optimised to any particular
microcontroller architecture. */

/* uxTopReadyPriority holds the priority of the highest priority ready
state task. */
/* 这部分代码的功能很明确，就是跟注释说的那样，更新 uxTopReadyPriority 用来记录就绪 */
/* 任务当中最高的优先级 */
#define taskRECORD_READY_PRIORITY(uxPriority)  \
    {                                          \
        if ((uxPriority) > uxTopReadyPriority) \
        {                                      \
            uxTopReadyPriority = (uxPriority); \
        }                                      \
    } /* taskRECORD_READY_PRIORITY */

/*-----------------------------------------------------------*/

/* uxTopReadyPriority是就绪最高优先级，下面的函数实现的功能是看一下这个优先级以内的
 * 所有的优先级相应的任务链表中是否有就绪的任务。查找的方式是根据优先级从高到低。
 * 这个查询处理退出的条件就是找到了就绪的任务,如果找完了所有的优先级链表没有就绪任务
 * 应该是一种错误。也就是说，查找的时候，其实有一定有就绪的任务存在了。 */
#define taskSELECT_HIGHEST_PRIORITY_TASK()                                              \
    {                                                                                   \
        UBaseType_t uxTopPriority = uxTopReadyPriority;                                 \
                                                                                        \
        /* Find the highest priority queue that contains ready tasks. */                \
        while (listLIST_IS_EMPTY(&(pxReadyTasksLists[uxTopPriority])))                  \
        {                                                                               \
            configASSERT(uxTopPriority);                                                \
            --uxTopPriority;                                                            \
        }                                                                               \
                                                                                        \
        /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of        \
        the	same priority get an equal share of the processor time. */                  \
        listGET_OWNER_OF_NEXT_ENTRY(pxCurrentTCB, &(pxReadyTasksLists[uxTopPriority])); \
        uxTopReadyPriority = uxTopPriority;                                             \
    } /* taskSELECT_HIGHEST_PRIORITY_TASK */

/*-----------------------------------------------------------*/

/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
they are only required when a port optimised method of task selection is
being used. */
#define taskRESET_READY_PRIORITY(uxPriority)
#define portRESET_READY_PRIORITY(uxPriority, uxTopReadyPriority)

#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */

/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
performed in a way that is tailored to the particular microcontroller
architecture being used. */

/* A port optimised version is provided.  Call the port defined macros. */
#define taskRECORD_READY_PRIORITY(uxPriority) portRECORD_READY_PRIORITY(uxPriority, uxTopReadyPriority)

/*-----------------------------------------------------------*/

#define taskSELECT_HIGHEST_PRIORITY_TASK()                                              \
    {                                                                                   \
        UBaseType_t uxTopPriority;                                                      \
                                                                                        \
        /* Find the highest priority list that contains ready tasks. */                 \
        /* 找到就绪的任务中的最高优先级 */                                              \
        portGET_HIGHEST_PRIORITY(uxTopPriority, uxTopReadyPriority);                    \
        /* 既然是有就绪的任务，那么这个任务链表肯定不能是空的 */                        \
        configASSERT(listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[uxTopPriority])) > 0); \
        /* pxCurrentTCB 用来处理最高就绪任务 */                                         \
        listGET_OWNER_OF_NEXT_ENTRY(pxCurrentTCB, &(pxReadyTasksLists[uxTopPriority])); \
    } /* taskSELECT_HIGHEST_PRIORITY_TASK() */

/*-----------------------------------------------------------*/

/* A port optimised version is provided, call it only if the TCB being reset
is being referenced from a ready list.  If it is referenced from a delayed
or suspended list then it won't be in a ready list. */
#define taskRESET_READY_PRIORITY(uxPriority)                                               \
    {                                                                                      \
        /* 根据指定的优先级来看相应优先级的就绪任务链表是否为空，如果是空，那么执行下面的动作 */ \
        if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[(uxPriority)])) == (UBaseType_t)0) \
        {                                                                                  \
            portRESET_READY_PRIORITY((uxPriority), (uxTopReadyPriority));                  \
        }                                                                                  \
    }

#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */

/*-----------------------------------------------------------*/

/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
count overflows. */
/* 下面的操作其实是借用一个临时的指针变量对pxDelayedTaskList和pxOverflowDelayedTaskList
 * 进行了一个数据交换。延迟的任务链表以及溢出延迟任务链表做交换，溢出数目增加1。之后，
 * 复位下一次任务解锁时间。 */
#define taskSWITCH_DELAYED_LISTS()                                                \
    {                                                                             \
        List_t *pxTemp;                                                           \
                                                                                  \
        /* The delayed tasks list should be empty when the lists are switched. */ \
        configASSERT((listLIST_IS_EMPTY(pxDelayedTaskList)));                     \
                                                                                  \
        pxTemp = pxDelayedTaskList;                                               \
        pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
        pxOverflowDelayedTaskList = pxTemp;                                       \
        xNumOfOverflows++;                                                        \
        prvResetNextTaskUnblockTime();                                            \
    }

/*-----------------------------------------------------------*/

/*
 * Place the task represented by pxTCB into the appropriate ready list for
 * the task.  It is inserted at the end of the list.
 */
/* 这里涉及到的2条带有trace的暂时都是没生效的，有效的部分是另外两行代码 */
/* 从这段代码看，其实就绪任务链表按照优先级是有多个的，每一个优先级一个 */
#define prvAddTaskToReadyList(pxTCB)                                                       \
    traceMOVED_TASK_TO_READY_STATE(pxTCB);                                                 \
    taskRECORD_READY_PRIORITY((pxTCB)->uxPriority);                                        \
    vListInsertEnd(&(pxReadyTasksLists[(pxTCB)->uxPriority]), &((pxTCB)->xStateListItem)); \
    tracePOST_MOVED_TASK_TO_READY_STATE(pxTCB)
/*-----------------------------------------------------------*/

/*
 * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 * where NULL is used to indicate that the handle of the currently executing
 * task should be used in place of the parameter.  This macro simply checks to
 * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 */
/* 如果传入的指针是NULL，那么就获取当前任务的TCB指针，否则直接转为TCB的指针类型 */
#define prvGetTCBFromHandle(pxHandle) (((pxHandle) == NULL) ? (TCB_t *)pxCurrentTCB : (TCB_t *)(pxHandle))

/* The item value of the event list item is normally used to hold the priority
of the task to which it belongs (coded to allow it to be held in reverse
priority order).  However, it is occasionally borrowed for other purposes.  It
is important its value is not updated due to a task priority change while it is
being used for another purpose.  The following bit definition is used to inform
the scheduler that the value should not be changed - in which case it is the
responsibility of whichever module is using the value to ensure it gets set back
to its original value when it is released. */
#if (configUSE_16_BIT_TICKS == 1)
#define taskEVENT_LIST_ITEM_VALUE_IN_USE 0x8000U
#else
#define taskEVENT_LIST_ITEM_VALUE_IN_USE 0x80000000UL
#endif

/*
 * Task control block.  A task control block (TCB) is allocated for each task,
 * and stores task state information, including a pointer to the task's context
 * (the task's run time environment, including register values)
 */
typedef struct tskTaskControlBlock
{
    /* < Points to the location of the last item placed on the tasks stack.
     * THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    /* 这个就是针对每一个任务的stack的管理所用的指针 */
    volatile StackType_t *pxTopOfStack;

    /* 下面这部分在我现在的工程中无效，我的MCU中可能没有MPU */
#if (portUSING_MPU_WRAPPERS == 1)
    /*< The MPU settings are defined as part of the port layer.
     * THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    xMPU_SETTINGS xMPUSettings;
#endif

    /*< The list that the state list item of a task is reference
    from denotes the state of that task (Ready, Blocked, Suspended ). */
    /* 状态链表元素 */
    ListItem_t xStateListItem;
    /*< Used to reference a task from an event list. */
    /* 事件链表元素 */
    ListItem_t xEventListItem;
    /*< The priority of the task.  0 is the lowest priority. */
    /* 任务的优先级 */
    UBaseType_t uxPriority;
    /*< Points to the start of the stack. */
    /* 指针指向任务堆栈的开始 */
    StackType_t *pxStack;
    /*< Descriptive name given to the task when created.  Facilitates debugging only. */
    /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    /* 任务名称，调试信息 */
    char pcTaskName[configMAX_TASK_NAME_LEN];

    /* 当前的平台，下面的逻辑不成立 */
#if ((portSTACK_GROWTH > 0) || (configRECORD_STACK_HIGH_ADDRESS == 1))
    StackType_t *pxEndOfStack; /*< Points to the highest valid address for the stack. */
#endif

    /* 预处理条件不成立，这部分功能不开启 */
#if (portCRITICAL_NESTING_IN_TCB == 1)
    /*< Holds the critical section nesting depth for ports that
    do not maintain their own count in the port layer. */
    UBaseType_t uxCriticalNesting;
#endif

    /* 预处理条件不成立，这部分功能不开启 */
#if (configUSE_TRACE_FACILITY == 1)
    /*< Stores a number that increments each time a TCB is created.
    It allows debuggers to determine when a task has been deleted and then recreated. */
    UBaseType_t uxTCBNumber;
    /*< Stores a number specifically for use by third party trace code. */
    UBaseType_t uxTaskNumber;
#endif

    /* 这部分信息用于互斥信号的处理，一个优先级另一个是互斥信号保持（状态？） */
#if (configUSE_MUTEXES == 1)
    /*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    UBaseType_t uxBasePriority;
    UBaseType_t uxMutexesHeld;
#endif

    /* 当前的工程中，预处理条件不成立 */
#if (configUSE_APPLICATION_TASK_TAG == 1)
    TaskHookFunction_t pxTaskTag;
#endif

    /* 当前的工程中，预处理条件不成立 */
#if (configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0)
    void *pvThreadLocalStoragePointers[configNUM_THREAD_LOCAL_STORAGE_POINTERS];
#endif

    /* 当前的工程中，预处理条件不成立 */
#if (configGENERATE_RUN_TIME_STATS == 1)
    uint32_t ulRunTimeCounter; /*< Stores the amount of time the task has spent in the Running state. */
#endif

    /* 当前的工程中，预处理条件不成立 */
#if (configUSE_NEWLIB_REENTRANT == 1)
    /* Allocate a Newlib reent structure that is specific to this task.
       Note Newlib support has been included by popular demand, but is not
       used by the FreeRTOS maintainers themselves.  FreeRTOS is not
       responsible for resulting newlib operation.  User must be familiar with
       newlib and must provide system-wide implementations of the necessary
       stubs. Be warned that (at the time of writing) the current newlib design
       implements a system-wide malloc() that must be provided with locks. */
    struct _reent xNewLib_reent;
#endif

    /* 任务通知功能，包含一个通知值和一个通知状态 */
#if (configUSE_TASK_NOTIFICATIONS == 1)
    volatile uint32_t ulNotifiedValue;
    volatile uint8_t ucNotifyState;
#endif

    /* See the comments above the definition of
       tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
    /*lint !e731 Macro has been consolidated for readability reasons. */
#if (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0)
    /*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
    /* 用以指示是否使用静态的方式来进行存储分配 */
    uint8_t ucStaticallyAllocated;
#endif

    /* 当前的工程中，预处理条件不成立 */
#if (INCLUDE_xTaskAbortDelay == 1)
    uint8_t ucDelayAborted;
#endif
} tskTCB;

/* The old tskTCB name is maintained above then typedefed to the new TCB_t name
below to enable the use of older kernel aware debuggers. */
/* 这个数据结构仅在当前的文件中使用，因为在C文件中定义 */
typedef tskTCB TCB_t;

/*lint -save -e956 A manual analysis and inspection has been used to determine
which static variables must be declared volatile. */

PRIVILEGED_DATA TCB_t *volatile pxCurrentTCB = NULL;

/* Lists for ready and blocked tasks. --------------------*/
/* 任务就绪链表，跟优先级数目有关，每一个优先级有一个链表 */
/* 从注释说明也看得出来，这个是按照优先级分组后的链表 */
/*< Prioritised ready tasks. */
PRIVILEGED_DATA static List_t pxReadyTasksLists[configMAX_PRIORITIES] = {0};

void print_ready_task_list_size(void)
{
    printf("size of pxReadyTasksLists is %d\n", sizeof(pxReadyTasksLists));
}

/* 下面是2个delay任务的链表，其中一个是在tick计数器溢出的时候使用 */
/*< Delayed tasks. */
PRIVILEGED_DATA static List_t xDelayedTaskList1 = {0};
/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
PRIVILEGED_DATA static List_t xDelayedTaskList2 = {0};
/* 针对上面的两个概念，还有一对儿与之对应的指针 */
/*< Points to the delayed task list currently being used. */
PRIVILEGED_DATA static List_t *volatile pxDelayedTaskList = NULL;
/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
PRIVILEGED_DATA static List_t *volatile pxOverflowDelayedTaskList = NULL;
/*< Tasks that have been readied while the scheduler was suspended.
  They will be moved to the ready list when the scheduler is resumed. */
/* 当调度期刮起的时候就绪的任务当调度期恢复之后会移动到就绪连表之中 */
/* 这样，英国可以大致明确这个挂起任务链表以及挂起人物的概念了 */
PRIVILEGED_DATA static List_t xPendingReadyList = {0};

#if (INCLUDE_vTaskDelete == 1)
/* 这个链表是用以支持任务删除功能的 */
/*< Tasks that have been deleted - but their memory not yet freed. */
PRIVILEGED_DATA static List_t xTasksWaitingTermination = {0};
PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = (UBaseType_t)0U;

#endif

#if (INCLUDE_vTaskSuspend == 1)

PRIVILEGED_DATA static List_t xSuspendedTaskList = {0}; /*< Tasks that are currently suspended. */

#endif

/* Other file private variables. --------------------------------*/
PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = (UBaseType_t)0U;
PRIVILEGED_DATA static volatile TickType_t xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
/* 这里是xSchedulerRunning定义的地方，私有变量，看起来只有这个文件在用 */
PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks = (UBaseType_t)0U;
PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = (BaseType_t)0;
PRIVILEGED_DATA static UBaseType_t uxTaskNumber = (UBaseType_t)0U;
PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = (TickType_t)0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                       /*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */

/* Context switches are held pending while the scheduler is suspended.  Also,
interrupts must not manipulate the xStateListItem of a TCB, or any of the
lists the xStateListItem can be referenced from, if the scheduler is suspended.
If an interrupt needs to unblock a task while the scheduler is suspended then it
moves the task's event list item into the xPendingReadyList, ready for the
kernel to move the task from the pending ready list into the real ready list
when the scheduler is unsuspended.  The pending ready list itself can only be
accessed from a critical section. */
/* 如果调度器挂起，那么上下文切换也应该挂起。另外，当调度器挂起的时候中断不能够操作 */
/* TCB的状态链表元素以及元素所引用的链表。如果一个中断想要在调度器挂起的时候解除一个任务的阻塞情况， */
/* 那么它将会把任务的事情列表元素转移到挂起的就绪列表中，等待内核在调度器恢复的时候把它编程就绪状态。 */
/* pending就绪链表只能够从 critical section访问 */
/* 下面的这个变量从名称上看是为了标记调度器是否挂起的一个量 */
PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = (UBaseType_t)pdFALSE;

#if (configGENERATE_RUN_TIME_STATS == 1)

PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL; /*< Holds the value of a timer/counter the last time a task was switched in. */
PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;       /*< Holds the total amount of execution time as defined by the run time counter clock. */

#endif

/*lint -restore */

/*-----------------------------------------------------------*/

/* Callback function prototypes. --------------------------*/
#if (configCHECK_FOR_STACK_OVERFLOW > 0)
extern void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName);
#endif

#if (configUSE_TICK_HOOK > 0)
extern void vApplicationTickHook(void);
#endif

#if (configSUPPORT_STATIC_ALLOCATION == 1)
extern void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize);
#endif

/* File private functions. --------------------------------*/

/**
 * Utility task that simply returns pdTRUE if the task referenced by xTask is
 * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 * is in any other state.
 */
#if (INCLUDE_vTaskSuspend == 1)

static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) PRIVILEGED_FUNCTION;

#endif /* INCLUDE_vTaskSuspend */

/*
 * Utility to ready all the lists used by the scheduler.  This is called
 * automatically upon the creation of the first task.
 */
static void prvInitialiseTaskLists(void) PRIVILEGED_FUNCTION;

/*
 * The idle task, which as all tasks is implemented as a never ending loop.
 * The idle task is automatically created and added to the ready lists upon
 * creation of the first user task.
 *
 * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for this function is:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION_PROTO(prvIdleTask, pvParameters);

/*
 * Utility to free all memory allocated by the scheduler to hold a TCB,
 * including the stack pointed to by the TCB.
 *
 * This does not free memory allocated by the task itself (i.e. memory
 * allocated by calls to pvPortMalloc from within the tasks application code).
 */
#if (INCLUDE_vTaskDelete == 1)

static void prvDeleteTCB(TCB_t *pxTCB) PRIVILEGED_FUNCTION;

#endif

/*
 * Used only by the idle task.  This checks to see if anything has been placed
 * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 * and its TCB deleted.
 */
static void prvCheckTasksWaitingTermination(void) PRIVILEGED_FUNCTION;

/*
 * The currently executing task is entering the Blocked state.  Add the task to
 * either the current or the overflow delayed task list.
 */
static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely) PRIVILEGED_FUNCTION;

/*
 * Fills an TaskStatus_t structure with information on each task that is
 * referenced from the pxList list (which may be a ready list, a delayed list,
 * a suspended list, etc.).
 *
 * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 * NORMAL APPLICATION CODE.
 */
#if (configUSE_TRACE_FACILITY == 1)

static UBaseType_t prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState) PRIVILEGED_FUNCTION;

#endif

/*
 * Searches pxList for a task with name pcNameToQuery - returning a handle to
 * the task if it is found, or NULL if the task is not found.
 */
#if (INCLUDE_xTaskGetHandle == 1)

static TCB_t *prvSearchForNameWithinSingleList(List_t *pxList, const char pcNameToQuery[]) PRIVILEGED_FUNCTION;

#endif

/*
 * When a task is created, the stack of the task is filled with a known value.
 * This function determines the 'high water mark' of the task stack by
 * determining how much of the stack remains at the original preset value.
 */
#if ((configUSE_TRACE_FACILITY == 1) || (INCLUDE_uxTaskGetStackHighWaterMark == 1))

static uint16_t prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) PRIVILEGED_FUNCTION;

#endif

/*
 * Return the amount of time, in ticks, that will pass before the kernel will
 * next move a task from the Blocked state to the Running state.
 *
 * This conditional compilation should use inequality to 0, not equality to 1.
 * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 * set to a value other than 1.
 */
#if (configUSE_TICKLESS_IDLE != 0)

static TickType_t prvGetExpectedIdleTime(void) PRIVILEGED_FUNCTION;

#endif

/*
 * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 * will exit the Blocked state.
 */
static void prvResetNextTaskUnblockTime(void);

#if ((configUSE_TRACE_FACILITY == 1) && (configUSE_STATS_FORMATTING_FUNCTIONS > 0))

/*
 * Helper function used to pad task names with spaces when printing out
 * human readable tables of task information.
 */
static char *prvWriteNameToBuffer(char *pcBuffer, const char *pcTaskName) PRIVILEGED_FUNCTION;

#endif

/*
 * Called after a Task_t structure has been allocated either statically or
 * dynamically to fill in the structure's members.
 */
static void prvInitialiseNewTask(TaskFunction_t pxTaskCode,
                                 const char *const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                 const uint32_t ulStackDepth,
                                 void *const pvParameters,
                                 UBaseType_t uxPriority,
                                 TaskHandle_t *const pxCreatedTask,
                                 TCB_t *pxNewTCB,
                                 const MemoryRegion_t *const xRegions) PRIVILEGED_FUNCTION;

/*
 * Called after a new task has been created and initialised to place the task
 * under the control of the scheduler.
 */
static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) PRIVILEGED_FUNCTION;

/*
 * freertos_tasks_c_additions_init() should only be called if the user definable
 * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 * called by the function.
 */
#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT

static void freertos_tasks_c_additions_init(void) PRIVILEGED_FUNCTION;

#endif

/*-----------------------------------------------------------*/
#if (configSUPPORT_STATIC_ALLOCATION == 1)

TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode,
                               /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                               const char *const pcName,
                               const uint32_t ulStackDepth,
                               void *const pvParameters,
                               UBaseType_t uxPriority,
                               StackType_t *const puxStackBuffer,
                               StaticTask_t *const pxTaskBuffer)
{
    TCB_t *pxNewTCB;
    TaskHandle_t xReturn;

    /* 首先得确认提供给任务创建用的buffer是有效的 */
    /* 第二个buffer的具体作用后面得关注一下，从名称看不容易看出作用 */
    configASSERT(puxStackBuffer != NULL);
    configASSERT(pxTaskBuffer != NULL);

    /* 下面这部分预编译条件是成立的 */
#if (configASSERT_DEFINED == 1)
    {
        /* Sanity check that the size of the structure used to declare a
           variable of type StaticTask_t equals the size of the real task
           structure. */
        /* 动态以及静态的TCB大小应该是一样的，其实这个之前我看其他的代码的时候测试验证过了 */
        /* 看到这里，多少有点知道最后一个参数是干什么的，可能是提供一个任务句柄 */
        volatile size_t xSize = sizeof(StaticTask_t);
        configASSERT(xSize == sizeof(TCB_t));
    }
#endif /* configASSERT_DEFINED */

    /* 下面的条件成立的时候才是有意义的，而且这个其实通过前面的断言是保证过了的 */
    if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL))
    {
        /* The memory used for the task's TCB and stack are passed into this
           function - use them. */
        /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment,
        and the size is checked by an assert. */
        /* 前面保证两种数据类型的空间类型大小一致其实也是为这个转换做保证 */
        pxNewTCB = (TCB_t *)pxTaskBuffer;
        /* 指定堆栈位置，相比之下动态创建任务的时候这里是直接从heap中申请存储空间 */
        pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;

/*lint !e731 Macro has been consolidated for readability reasons. */
#if (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0)
        {
            /* Tasks can be created statically or dynamically, so note this
               task was created statically in case the task is later deleted. */
            /* 用以指示任务的创建类型 */
            pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
        }
#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

        /* 初始化任务并且把任务增加到就绪链表 */
        prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL);
        prvAddNewTaskToReadyList(pxNewTCB);
    }
    else
    {
        xReturn = NULL;
    }

    return xReturn;
}

#endif /* SUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

#if ((portUSING_MPU_WRAPPERS == 1) && (configSUPPORT_STATIC_ALLOCATION == 1))

BaseType_t xTaskCreateRestrictedStatic(const TaskParameters_t *const pxTaskDefinition, TaskHandle_t *pxCreatedTask)
{
    TCB_t *pxNewTCB;
    BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;

    configASSERT(pxTaskDefinition->puxStackBuffer != NULL);
    configASSERT(pxTaskDefinition->pxTaskBuffer != NULL);

    if ((pxTaskDefinition->puxStackBuffer != NULL) && (pxTaskDefinition->pxTaskBuffer != NULL))
    {
        /* Allocate space for the TCB.  Where the memory comes from depends
        on the implementation of the port malloc function and whether or
        not static allocation is being used. */
        pxNewTCB = (TCB_t *)pxTaskDefinition->pxTaskBuffer;

        /* Store the stack location in the TCB. */
        pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;

#if (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0)
        {
            /* Tasks can be created statically or dynamically, so note this
            task was created statically in case the task is later deleted. */
            pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
        }
#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

        prvInitialiseNewTask(pxTaskDefinition->pvTaskCode,
                             pxTaskDefinition->pcName,
                             (uint32_t)pxTaskDefinition->usStackDepth,
                             pxTaskDefinition->pvParameters,
                             pxTaskDefinition->uxPriority,
                             pxCreatedTask, pxNewTCB,
                             pxTaskDefinition->xRegions);

        prvAddNewTaskToReadyList(pxNewTCB);
        xReturn = pdPASS;
    }

    return xReturn;
}

#endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

#if ((portUSING_MPU_WRAPPERS == 1) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))

BaseType_t xTaskCreateRestricted(const TaskParameters_t *const pxTaskDefinition, TaskHandle_t *pxCreatedTask)
{
    TCB_t *pxNewTCB;
    BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;

    configASSERT(pxTaskDefinition->puxStackBuffer);

    if (pxTaskDefinition->puxStackBuffer != NULL)
    {
        /* Allocate space for the TCB.  Where the memory comes from depends
        on the implementation of the port malloc function and whether or
        not static allocation is being used. */
        pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));

        if (pxNewTCB != NULL)
        {
            /* Store the stack location in the TCB. */
            pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;

#if (configSUPPORT_STATIC_ALLOCATION == 1)
            {
                /* Tasks can be created statically or dynamically, so note
                this task had a statically allocated stack in case it is
                later deleted.  The TCB was allocated dynamically. */
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
            }
#endif

            prvInitialiseNewTask(pxTaskDefinition->pvTaskCode,
                                 pxTaskDefinition->pcName,
                                 (uint32_t)pxTaskDefinition->usStackDepth,
                                 pxTaskDefinition->pvParameters,
                                 pxTaskDefinition->uxPriority,
                                 pxCreatedTask, pxNewTCB,
                                 pxTaskDefinition->xRegions);

            prvAddNewTaskToReadyList(pxNewTCB);
            xReturn = pdPASS;
        }
    }

    return xReturn;
}

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if (configSUPPORT_DYNAMIC_ALLOCATION == 1)

BaseType_t xTaskCreate(TaskFunction_t pxTaskCode,
                       /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                       const char *const pcName,
                       const configSTACK_DEPTH_TYPE usStackDepth,
                       void *const pvParameters,
                       UBaseType_t uxPriority,
                       TaskHandle_t *const pxCreatedTask)
{
    TCB_t *pxNewTCB;
    BaseType_t xReturn;

    /* If the stack grows down then allocate the stack then the TCB so the stack
   does not grow into the TCB.  Likewise if the stack grows up then allocate
   the TCB then the stack. */
#if (portSTACK_GROWTH > 0)
    /* 针对当前的MCU工程配置，下面这部分不用看 */
    {
        /* Allocate space for the TCB.  Where the memory comes from depends on
           the implementation of the port malloc function and whether or not static
           allocation is being used. */
        pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));

        if (pxNewTCB != NULL)
        {
            /* Allocate space for the stack used by the task being created.
               The base of the stack memory stored in the TCB so the task can
               be deleted later if required. */
            /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
            pxNewTCB->pxStack = (StackType_t *)pvPortMalloc((((size_t)usStackDepth) * sizeof(StackType_t)));

            if (pxNewTCB->pxStack == NULL)
            {
                /* Could not allocate the stack.  Delete the allocated TCB. */
                vPortFree(pxNewTCB);
                pxNewTCB = NULL;
            }
        }
    }
#else  /* portSTACK_GROWTH */
    {
        StackType_t *pxStack;

        /* Allocate space for the stack used by the task being created. */
        /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
        /* 从FreeRTOS的heap中申请任务堆栈空间 */
        pxStack = (StackType_t *)pvPortMalloc((((size_t)usStackDepth) * sizeof(StackType_t)));

        /* 如果堆栈申请成功 */
        if (pxStack != NULL)
        {
            /* Allocate space for the TCB. */
            /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
            /* 从FreeRTOS的heap中申请任务控制块的存储空间 */
            pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));

            /* 如果任务控制块的存储申请成功 */
            if (pxNewTCB != NULL)
            {
                /* Store the stack location in the TCB. */
                /* 任务堆栈与任务控制块绑定 */
                pxNewTCB->pxStack = pxStack;
            }
            else
            {
                /* The stack cannot be used as the TCB was not created.  Free
                   it again. */
                /* 任务控制块的存储申请失败，释放前面的堆栈空间 */
                vPortFree(pxStack);
            }
        }
        else
        {
            /* 任务堆栈空间申请都失败的时候，直接标注任务控制块的申请失败 */
            pxNewTCB = NULL;
        }
    }
#endif /* portSTACK_GROWTH */

    /* 任务控制块创建成功 */
    if (pxNewTCB != NULL)
    {
        /*lint !e731 Macro has been consolidated for readability reasons. */
#if (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0)
        {
            /* Tasks can be created statically or dynamically, so note this
               task was created dynamically in case it is later deleted. */
            /* 这个接口其实是动态创建任务，这里做动态创建的标注。 */
            pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
        }
#endif /* configSUPPORT_STATIC_ALLOCATION */

        /* 初始化新的任务并且加入到任务就绪列表 */
        prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL);
        prvAddNewTaskToReadyList(pxNewTCB);
        xReturn = pdPASS;
    }
    else
    {
        /* 任务控制块创建失败，提示存储不够 */
        xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    }

    return xReturn;
}

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewTask(
    TaskFunction_t pxTaskCode,
    /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    const char *const pcName,
    const uint32_t ulStackDepth,
    void *const pvParameters,
    UBaseType_t uxPriority,
    TaskHandle_t *const pxCreatedTask,
    TCB_t *pxNewTCB,
    const MemoryRegion_t *const xRegions)
{
    StackType_t *pxTopOfStack;
    UBaseType_t x;

    /* 目前的工程中这部分是不使能的 */
#if (portUSING_MPU_WRAPPERS == 1)
    /* Should the task be created in privileged mode? */
    BaseType_t xRunPrivileged;
    if ((uxPriority & portPRIVILEGE_BIT) != 0U)
    {
        xRunPrivileged = pdTRUE;
    }
    else
    {
        xRunPrivileged = pdFALSE;
    }
    uxPriority &= ~portPRIVILEGE_BIT;
#endif /* portUSING_MPU_WRAPPERS == 1 */

/* Avoid dependency on memset() if it is not required. */
/* 目前这部分功能也是不开启的, tskSET_NEW_STACKS_TO_KNOWN_VALUE逻辑值为0 */
#if (tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1)
    {
        /* Fill the stack with a known value to assist debugging. */
        /* 填充值tskSTACK_FILL_BYTE为0xA5 */
        (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
    }
#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */

/* Calculate the top of stack address.  This depends on whether the stack
grows from high memory to low (as per the 80x86) or vice versa.
portSTACK_GROWTH is used to make the result positive or negative as required
by the port. */
/* 当前项目中portSTACK_GROWTH为-1，因此下面的逻辑生效 */
#if (portSTACK_GROWTH < 0)
    {
        /* 计算堆栈栈顶 */
        pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
        /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.
        Size differences accounted for using portPOINTER_SIZE_TYPE type. */
        /* 对齐是按照portBYTE_ALIGNMENT=8来处理的，这个是芯片架构决定的 */
        /* portBYTE_ALIGNMENT_MASK的数值为7，0b111,  因此下面的取值是取地址的高29bit，由此看，其实这个架构决定的是：
         * 堆栈按照8字节来对齐，剩下的7个地址都被忽略了 */
        pxTopOfStack = (StackType_t *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));

        /* Check the alignment of the calculated top of stack is correct. */
        /* 确认地址一定是按照8的倍数来对齐的，我觉得有了前面的这个操作这一个断言应该是百分百满足的才对。 */
        /* 这里第一次正式遇到断言的设计，看一下具体的实现 */
        configASSERT((((portPOINTER_SIZE_TYPE)pxTopOfStack & (portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK) == 0UL));

/* 下面这个配置没生效，用来记录栈顶的，可以辅助测试 */
#if (configRECORD_STACK_HIGH_ADDRESS == 1)
        {
            /* Also record the stack's high address, which may assist
            debugging. */
            pxNewTCB->pxEndOfStack = pxTopOfStack;
        }
#endif /* configRECORD_STACK_HIGH_ADDRESS */
    }
#else  /* portSTACK_GROWTH */
    {
        /*portSTACK_GROWTH为-1，这段逻辑不生效*/
        pxTopOfStack = pxNewTCB->pxStack;

        /* Check the alignment of the stack buffer is correct. */
        configASSERT((((portPOINTER_SIZE_TYPE)pxNewTCB->pxStack & (portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK) == 0UL));

        /* The other extreme of the stack space is required if stack checking is
        performed. */
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
    }
#endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    /* 拷贝任务的名称，判断了结束符以提升效率 */
    for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++)
    {
        pxNewTCB->pcTaskName[x] = pcName[x];

        /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
        configMAX_TASK_NAME_LEN characters just in case the memory after the
        string is not accessible (extremely unlikely). */
        if (pcName[x] == 0x00)
        {
            break;
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    /* Ensure the name string is terminated in the case that the string length
    was greater or equal to configMAX_TASK_NAME_LEN. */
    /* 强制把任务名称的最后一个字节赋值为字符串的结束符以实现字符串的截止 */
    pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';

    /* This is used as an array index so must ensure it's not too large.  First
    remove the privilege bit if one is present. */
    /* 最大优先级的限制处理，看起来这个MAX不是最高的优先级数字，而是支持的优先级的数目 */
    if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES)
    {
        uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* 任务优先级的赋值以互斥信号支持下的优先级基础信息，我觉得这部分其实可以在CreateTask
     * 的函数块中实现，为什么转移到这里？ */
    pxNewTCB->uxPriority = uxPriority;
#if (configUSE_MUTEXES == 1)
    {
        pxNewTCB->uxBasePriority = uxPriority;
        pxNewTCB->uxMutexesHeld = 0;
    }
#endif /* configUSE_MUTEXES */

    /* 终于看到了链表的操作：初始化两个链表元素，一个是状态链表，另一个是事件链表 */
    vListInitialiseItem(&(pxNewTCB->xStateListItem));
    vListInitialiseItem(&(pxNewTCB->xEventListItem));

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
    back to	the containing TCB from a generic item in a list. */
    /* 设置链表元素归属对象 */
    listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);

    /* Event lists are always in priority order. */
    /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    /* 设置事件链表的元素数值，这个数值可以用于排序，设置的数值跟优先级有关，优先级越大数值越小 */
    listSET_LIST_ITEM_VALUE(&(pxNewTCB->xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)uxPriority);
    /* 设置链表元素归属对象 */
    listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);

/* 无效 */
#if (portCRITICAL_NESTING_IN_TCB == 1)
    {
        pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
    }
#endif /* portCRITICAL_NESTING_IN_TCB */

/* 无效 */
#if (configUSE_APPLICATION_TASK_TAG == 1)
    {
        pxNewTCB->pxTaskTag = NULL;
    }
#endif /* configUSE_APPLICATION_TASK_TAG */

/* 无效 */
#if (configGENERATE_RUN_TIME_STATS == 1)
    {
        pxNewTCB->ulRunTimeCounter = 0UL;
    }
#endif /* configGENERATE_RUN_TIME_STATS */

/* 无效 */
#if (portUSING_MPU_WRAPPERS == 1)
    {
        vPortStoreTaskMPUSettings(&(pxNewTCB->xMPUSettings), xRegions, pxNewTCB->pxStack, ulStackDepth);
    }
#else
    {
        /* Avoid compiler warning about unreferenced parameter. */
        (void)xRegions;
    }
#endif

    /* 无效 */
#if (configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0)
    {
        for (x = 0; x < (UBaseType_t)configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++)
        {
            pxNewTCB->pvThreadLocalStoragePointers[x] = NULL;
        }
    }
#endif

#if (configUSE_TASK_NOTIFICATIONS == 1)
    {
        /* 如果开启了任务通知功能，这个通知数值初始化的时候清零，状态设置为不等待通知 */
        /* 可能状态：不等待通知、等待通知、接收到 */
        pxNewTCB->ulNotifiedValue = 0;
        pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    }
#endif

/* 目前这个配置没有使能 */
#if (configUSE_NEWLIB_REENTRANT == 1)
    {
        /* Initialise this task's Newlib reent structure. */
        _REENT_INIT_PTR((&(pxNewTCB->xNewLib_reent)));
    }
#endif

/* 无效 */
#if (INCLUDE_xTaskAbortDelay == 1)
    {
        pxNewTCB->ucDelayAborted = pdFALSE;
    }
#endif

/* Initialize the TCB stack to look as if the task was already running,
but had been interrupted by the scheduler.  The return address is set
to the start of the task function. Once the stack has been initialised
the top of stack variable is updated. */
#if (portUSING_MPU_WRAPPERS == 1)
    {
        pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged);
    }
#else  /* portUSING_MPU_WRAPPERS */
    {
        /* 初始化堆栈信息，具体的功能需要查看这个函数的设计 */
        pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    }
#endif /* portUSING_MPU_WRAPPERS */

    /* 如果创建任务的时候指定了任务的句柄 */
    if ((void *)pxCreatedTask != NULL)
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
        change the created task's priority, delete the created task, etc.*/
        /* 句柄信息直接指向任务控制块 */
        *pxCreatedTask = (TaskHandle_t)pxNewTCB;
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB)
{
    /* Ensure interrupts don't access the task lists while the lists are being
       updated. */
    /* 进入临界保护 */
    taskENTER_CRITICAL();
    {
        /* 当前的任务数加1，这个数应该是就绪的任务数 */
        uxCurrentNumberOfTasks++;
        /* 从命名信息看，下面判断的是当前是否有已经就绪的任务，成立的话说明没有就绪的任务 */
        if (pxCurrentTCB == NULL)
        {
            /* There are no other tasks, or all the other tasks are in
               the suspended state - make this the current task. */
            /* 如果没有就绪的任务，那么就把这个设置为当前的就绪任务 */
            pxCurrentTCB = pxNewTCB;

            if (uxCurrentNumberOfTasks == (UBaseType_t)1)
            {
                /* This is the first task to be created so do the preliminary
                   initialisation required.  We will not recover if this call
                   fails, but we will report the failure. */
                /* 如果当前就绪的任务数目是1，那么初始化任务链表 */
                prvInitialiseTaskLists();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            /* If the scheduler is not already running, make this task the
               current task if it is the highest priority task to be created
               so far. */
            /* 如果调度器还没有运行起来 */
            /* 之前猜测过这个意思，其实采用调度器状态获取的函数更容易理解，但是效率不如这个高 */
            if (xSchedulerRunning == pdFALSE)
            {
                /* 更高优先级的任务设置为就绪任务，调度开时候先执行 */
                if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority)
                {
                    pxCurrentTCB = pxNewTCB;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        /* 这里应该是任务编号的意思而不是任务数目的意思 */
        uxTaskNumber++;

#if (configUSE_TRACE_FACILITY == 1)
        {
            /* Add a counter into the TCB for tracing only. */
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
#endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE(pxNewTCB);

        /* 任务加入到相应优先级的就绪任务链表 */
        prvAddTaskToReadyList(pxNewTCB);

        /* 无效 */
        portSETUP_TCB(pxNewTCB);
    }
    taskEXIT_CRITICAL();

    /* 如果任务调度已经运行了 */
    /* 可以用调度器状态获取函数代替提高可读性，但是效率不高 */
    if (xSchedulerRunning != pdFALSE)
    {
        /* If the created task is of a higher priority than the current task
           then it should run now. */
        /* 更高优先级的任务就绪了 */
        if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority)
        {
            /* 如果抢占模式，那么执行任务切换 */
            taskYIELD_IF_USING_PREEMPTION();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
/*-----------------------------------------------------------*/

/* 当前的工程中如下预处理条件成立 */
#if (INCLUDE_vTaskDelete == 1)

void vTaskDelete(TaskHandle_t xTaskToDelete)
{
    TCB_t *pxTCB;

    /* 进入临界保护，主要的考虑点可能是防止任务链表被异常处理 */
    taskENTER_CRITICAL();
    {
        /* If null is passed in here then it is the calling task that is
        being deleted. */
        /* 获取TCB，应该很容易实现，之前看过handler中其实最终放了TCB的指针 */
        pxTCB = prvGetTCBFromHandle(xTaskToDelete);

        /* Remove task from the ready list. */
        /* 从就绪链表中删除相应的节点 */
        if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
        {
            /* 如果相应优先级的就绪链表为空的时候会reset优先级就绪链表 */
            /* 是否为空的判断在这个reset的接口中判断 */
            taskRESET_READY_PRIORITY(pxTCB->uxPriority);
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /* Is the task waiting on an event also? */
        /* 清理事件列表 */
        if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
        {
            (void)uxListRemove(&(pxTCB->xEventListItem));
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /* Increment the uxTaskNumber also so kernel aware debuggers can
        detect that the task lists need re-generating.  This is done before
        portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
        not return. */
        /* 这个是用于第三方工具调试功能支持的 */
        uxTaskNumber++;

        /* 如果前面填写的句柄是NULL的时候，获取到的应该就是当前任务TCB，这一个条件成立 */
        if (pxTCB == pxCurrentTCB)
        {
            /* A task is deleting itself.  This cannot complete within the
            task itself, as a context switch to another task is required.
            Place the task in the termination list.  The idle task will
            check the termination list and free up any memory allocated by
            the scheduler for the TCB and stack of the deleted task. */
            /* 任务的自我删除其实是通过其他的手段来实现的，无法直接自我删除 */
            /* 把当前的任务信息增加到等待结束的链表之中 */
            vListInsertEnd(&xTasksWaitingTermination, &(pxTCB->xStateListItem));

            /* Increment the ucTasksDeleted variable so the idle task knows
            there is a task that has been deleted and that it should therefore
            check the xTasksWaitingTermination list. */
            /* 从这个注释看得出来，自我删除的操作其实是idle任务实现的 */
            /* idle任务判断是否有待删除的请求参考的是下面这个计数器 */
            ++uxDeletedTasksWaitingCleanUp;

            /* The pre-delete hook is primarily for the Windows simulator,
            in which Windows specific clean up operations are performed,
            after which it is not possible to yield away from this task -
            hence xYieldPending is used to latch that a context switch is
            required. */
            /* 下面这个接口其实是无效的 */
            portPRE_TASK_DELETE_HOOK(pxTCB, &xYieldPending);
        }
        else
        {
            /* 如果删除的不是当前任务，那么当前任务总数减1 */
            --uxCurrentNumberOfTasks;
            /* 接下来删除相应的TCB */
            prvDeleteTCB(pxTCB);

            /* Reset the next expected unblock time in case it referred to
            the task that has just been deleted. */
            prvResetNextTaskUnblockTime();
        }

        traceTASK_DELETE(pxTCB);
    }
    taskEXIT_CRITICAL();

    /* Force a reschedule if it is the currently running task that has just
    been deleted. */
    /* 可以用调度器状态获取函数代替提高可读性，但是效率不高 */
    /* 如果调度器在运行 */
    if (xSchedulerRunning != pdFALSE)
    {
        /* 如果是删除当前任务 */
        if (pxTCB == pxCurrentTCB)
        {
            /* 调度器不能有挂起没恢复的情况 */
            configASSERT(uxSchedulerSuspended == 0);
            /* 请求PendSV */
            portYIELD_WITHIN_API();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
}

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskDelayUntil == 1)

void vTaskDelayUntil(TickType_t *const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
    TickType_t xTimeToWake;
    BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

    /* 之前的唤醒时间指针，必须有效 */
    configASSERT(pxPreviousWakeTime);
    /* 延时，确切说是任务休眠，时间必须大于0，这个跟vTaskDelay是不同的 */
    configASSERT((xTimeIncrement > 0U));
    /* 调度器不能挂起 */
    configASSERT(uxSchedulerSuspended == 0);

    /* 标记任务挂起 */
    vTaskSuspendAll();
    {
        /* Minor optimisation.  The tick count cannot change in this
        block. */
        /* 常量记录当前的tick数值 */
        const TickType_t xConstTickCount = xTickCount;

        /* Generate the tick time at which the task wants to wake. */
        /* 唤醒时间为调用task时候的时间点加上延时时间 */
        xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

        /* 当前的tick小于之前唤醒的时刻，说明tick出现了溢出 */
        if (xConstTickCount < *pxPreviousWakeTime)
        {
            /* The tick count has overflowed since this function was
            lasted called.  In this case the only time we should ever
            actually delay is if the wake time has also	overflowed,
            and the wake time is greater than the tick time.  When this
            is the case it is as if neither time had overflowed. */
            /* 唤醒时刻小于上次唤醒时刻并且唤醒时刻大于当前的tick。这里没有什么补偿操作，
             * 其实是很好理解的，该补偿的部分都已经对等抵消了。因此，需要等待tick回滚
             * 之后做比较即可。因此，下面的条件成立后说明延时没到。 */
            if ((xTimeToWake < *pxPreviousWakeTime) && (xTimeToWake > xConstTickCount))
            {
                /* 标注需要延时 */
                xShouldDelay = pdTRUE;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            /* The tick time has not overflowed.  In this case we will
            delay if either the wake time has overflowed, and/or the
            tick time is less than the wake time. */
            /* tick没有溢出：如果下次唤醒的时刻小于上次的唤醒时刻需要等待tick溢出；
             * 或者下次唤醒时刻大于还大于当前tick，说明需要继续等待tick增加 */
            if ((xTimeToWake < *pxPreviousWakeTime) || (xTimeToWake > xConstTickCount))
            {
                /* 标注需要延时 */
                xShouldDelay = pdTRUE;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        /* Update the wake time ready for the next call. */
        *pxPreviousWakeTime = xTimeToWake;

        if (xShouldDelay != pdFALSE)
        {
            /* 接口无效 */
            traceTASK_DELAY_UNTIL(xTimeToWake);

            /* prvAddCurrentTaskToDelayedList() needs the block time, not
            the time to wake, so subtract the current tick count. */
            /* 加入到delayed task链表 */
            prvAddCurrentTaskToDelayedList(xTimeToWake - xConstTickCount, pdFALSE);
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    xAlreadyYielded = xTaskResumeAll();

    /* Force a reschedule if xTaskResumeAll has not already done so, we may
    have put ourselves to sleep. */
    if (xAlreadyYielded == pdFALSE)
    {
        /* 恢复挂起的时候如果没有调度，那么请求调度 */
        portYIELD_WITHIN_API();
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}


#endif /* INCLUDE_vTaskDelayUntil */
/*-----------------------------------------------------------*/

/* 下面的代码是生效的 */
#if (INCLUDE_vTaskDelay == 1)

void vTaskDelay(const TickType_t xTicksToDelay)
{
    BaseType_t xAlreadyYielded = pdFALSE;

    /* A delay time of zero just forces a reschedule. */
    if (xTicksToDelay > (TickType_t)0U)
    {
        /* 调度器的状态不能够挂起 */
        configASSERT(uxSchedulerSuspended == 0);
        vTaskSuspendAll();
        {
            /* 下面的接口无效 */
            traceTASK_DELAY();

            /* A task that is removed from the event list while the
            scheduler is suspended will not get placed in the ready
            list or removed from the blocked list until the scheduler
            is resumed.

            This task cannot be in an event list as it is the currently
            executing task. */
            /* 把当前的任务加入到delayed任务链表 */
            /* 看到这里，终于知道了前面一直迷糊不知道什么意思的delayed task list
             * 是一个什么概念了 */
            prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
        }
        /* 调度器恢复，xTaskResumeAll返回值如果是True意味着发生了一次调度 */
        xAlreadyYielded = xTaskResumeAll();
    }
    else
    {
        /* 以下接口无效 */
        mtCOVERAGE_TEST_MARKER();
    }

    /* Force a reschedule if xTaskResumeAll has not already done so, we may
    have put ourselves to sleep. */
    /* 调度器恢复的时候如果没发生调度，那么执行任务调度请求，否则直接结束 */
    if (xAlreadyYielded == pdFALSE)
    {
        /* 如果传入的参数是0，那么会直接调用下面这个接口 */
        /* 而下面这个接口的功能其实是直接触发任务调度 */
        portYIELD_WITHIN_API();
    }
    else
    {
        /* 以下接口无效 */
        mtCOVERAGE_TEST_MARKER();
    }
}

#endif /* INCLUDE_vTaskDelay */
/*-----------------------------------------------------------*/

#if ((INCLUDE_eTaskGetState == 1) || (configUSE_TRACE_FACILITY == 1))

eTaskState eTaskGetState(TaskHandle_t xTask)
{
    eTaskState eReturn;
    List_t *pxStateList;
    const TCB_t *const pxTCB = (TCB_t *)xTask;

    configASSERT(pxTCB);

    if (pxTCB == pxCurrentTCB)
    {
        /* The task calling this function is querying its own state. */
        eReturn = eRunning;
    }
    else
    {
        taskENTER_CRITICAL();
        {
            pxStateList = (List_t *)listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
        }
        taskEXIT_CRITICAL();

        if ((pxStateList == pxDelayedTaskList) || (pxStateList == pxOverflowDelayedTaskList))
        {
            /* The task being queried is referenced from one of the Blocked
            lists. */
            eReturn = eBlocked;
        }

#if (INCLUDE_vTaskSuspend == 1)
        else if (pxStateList == &xSuspendedTaskList)
        {
            /* The task being queried is referenced from the suspended
            list.  Is it genuinely suspended or is it block
            indefinitely? */
            if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL)
            {
                eReturn = eSuspended;
            }
            else
            {
                eReturn = eBlocked;
            }
        }
#endif

#if (INCLUDE_vTaskDelete == 1)
        else if ((pxStateList == &xTasksWaitingTermination) || (pxStateList == NULL))
        {
            /* The task being queried is referenced from the deleted
            tasks list, or it is not referenced from any lists at
            all. */
            eReturn = eDeleted;
        }
#endif

        else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
        {
            /* If the task is not in any other state, it must be in the
            Ready (including pending ready) state. */
            eReturn = eReady;
        }
    }

    return eReturn;
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */

#endif /* INCLUDE_eTaskGetState */
/*-----------------------------------------------------------*/

#if (INCLUDE_uxTaskPriorityGet == 1)

UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask)
{
    TCB_t *pxTCB;
    UBaseType_t uxReturn;

    /* 进入临界保护 */
    taskENTER_CRITICAL();
    {
        /* If null is passed in here then it is the priority of the that
        called uxTaskPriorityGet() that is being queried. */
        pxTCB = prvGetTCBFromHandle(xTask);
        /* 获得了TCB的信息之后，直接从中取出优先级的信息 */
        uxReturn = pxTCB->uxPriority;
    }
    /* 退出临界保护 */
    taskEXIT_CRITICAL();

    return uxReturn;
}

#endif /* INCLUDE_uxTaskPriorityGet */
/*-----------------------------------------------------------*/

#if (INCLUDE_uxTaskPriorityGet == 1)

UBaseType_t uxTaskPriorityGetFromISR(TaskHandle_t xTask)
{
    TCB_t *pxTCB;
    UBaseType_t uxReturn, uxSavedInterruptState;

    /* RTOS ports that support interrupt nesting have the concept of a
    maximum	system call (or maximum API call) interrupt priority.
    Interrupts that are	above the maximum system call priority are keep
    permanently enabled, even when the RTOS kernel is in a critical section,
    but cannot make any calls to FreeRTOS API functions.  If configASSERT()
    is defined in FreeRTOSConfig.h then
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
    failure if a FreeRTOS API function is called from an interrupt that has
    been assigned a priority above the configured maximum system call
    priority.  Only FreeRTOS functions that end in FromISR can be called
    from interrupts	that have been assigned a priority at or (logically)
    below the maximum system call interrupt priority.  FreeRTOS maintains a
    separate interrupt safe API to ensure interrupt entry is as fast and as
    simple as possible.  More information (albeit Cortex-M specific) is
    provided on the following link:
    http://www.freertos.org/RTOS-Cortex-M3-M4.html */
    /* 下面的接口无效 */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    /* uxSavedInterruptState保存之前的优先级，之后basepri设置为configMAX_SYSCALL_INTERRUPT_PRIORITY */
    /* 这样，优先级高于80的中断都被屏蔽掉了 */
    uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* If null is passed in here then it is the priority of the calling
        task that is being queried. */
        /* 跟普通函数一样，获取优先级 */
        pxTCB = prvGetTCBFromHandle(xTask);
        uxReturn = pxTCB->uxPriority;
    }
    /* 恢复之前的basepri */
    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptState);

    return uxReturn;
}

#endif /* INCLUDE_uxTaskPriorityGet */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskPrioritySet == 1)

void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
    TCB_t *pxTCB;
    UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
    BaseType_t xYieldRequired = pdFALSE;

    /* 首先确保新的任务优先级不高于系统支持的最高优先级数目 */
    /*  */
    configASSERT((uxNewPriority < configMAX_PRIORITIES));

    /* Ensure the new priority is valid. */
    /* 如果传入大于等于最大的优先级数目（如果有了前面的断言，这个可能就不存在了） */
    if (uxNewPriority >= (UBaseType_t)configMAX_PRIORITIES)
    {
        uxNewPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* 进入到临界保护 */
    taskENTER_CRITICAL();
    {
        /* If null is passed in here then it is the priority of the calling
        task that is being changed. */
        /* 根据句柄获取TCB信息 */
        pxTCB = prvGetTCBFromHandle(xTask);

        traceTASK_PRIORITY_SET(pxTCB, uxNewPriority);

#if (configUSE_MUTEXES == 1)
        {
            /* 获取当前的基础优先级 */
            uxCurrentBasePriority = pxTCB->uxBasePriority;
        }
#else
        {
            uxCurrentBasePriority = pxTCB->uxPriority;
        }
#endif

        /* 当前的基础优先级不等于需要修改的优先级才有修改的需要 */
        if (uxCurrentBasePriority != uxNewPriority)
        {
            /* The priority change may have readied a task of higher
            priority than the calling task. */
            /* 任务优先级需要提升 */
            if (uxNewPriority > uxCurrentBasePriority)
            {
                /* 非当前任务 */
                if (pxTCB != pxCurrentTCB)
                {
                    /* The priority of a task other than the currently
                    running task is being raised.  Is the priority being
                    raised above that of the running task? */
                    /* 提升后的优先级比当前任务高，需要触发任务调度 */
                    if (uxNewPriority >= pxCurrentTCB->uxPriority)
                    {
                        xYieldRequired = pdTRUE;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                else
                {
                    /* The priority of the running task is being raised,
                    but the running task must already be the highest
                    priority task able to run so no yield is required. */
                }
            }
            else if (pxTCB == pxCurrentTCB)
            {
                /* 优先级不提升，但是是处理当前的任务，需要触发任务调度 */
                /* Setting the priority of the running task down means
                there may now be another task of higher priority that
                is ready to execute. */
                xYieldRequired = pdTRUE;
            }
            else
            {
                /* Setting the priority of any other task down does not
                require a yield as the running task must be above the
                new priority of the task being modified. */
            }

            /* Remember the ready list the task might be referenced from
            before its uxPriority member is changed so the
            taskRESET_READY_PRIORITY() macro can function correctly. */
            uxPriorityUsedOnEntry = pxTCB->uxPriority;

#if (configUSE_MUTEXES == 1)
            {
                /* Only change the priority being used if the task is not
                currently using an inherited priority. */
                /* 基础优先级等于优先级 */
                if (pxTCB->uxBasePriority == pxTCB->uxPriority)
                {
                    /* 优先级更新 */
                    pxTCB->uxPriority = uxNewPriority;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                /* The base priority gets set whatever. */
                /* 基础任务更新为最新的优先级，到此还没看明白uxBasePriority的作用 */
                pxTCB->uxBasePriority = uxNewPriority;
            }
#else
            {
                pxTCB->uxPriority = uxNewPriority;
            }
#endif

            /* Only reset the event list item value if the value is not
            being used for anything else. */
            /* xEventListItem的最高位是0 */
            if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL)
            {
                /* xEventListItem 设置为最高优先级数减去uxNewPriority */
                listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem), ((TickType_t)configMAX_PRIORITIES - (TickType_t)uxNewPriority)); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* If the task is in the blocked or suspended list we need do
            nothing more than change its priority variable. However, if
            the task is in a ready list it needs to be removed and placed
            in the list appropriate to its new priority. */
            if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), &(pxTCB->xStateListItem)) != pdFALSE)
            {
                /* The task is currently in its ready list - remove before
                adding it to it's new ready list.  As we are in a critical
                section we can do this even if the scheduler is suspended. */
                if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
                {
                    /* It is known that the task is in its ready list so
                    there is no need to check again and the port level
                    reset macro can be called directly. */
                    portRESET_READY_PRIORITY(uxPriorityUsedOnEntry, uxTopReadyPriority);
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
                prvAddTaskToReadyList(pxTCB);
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if (xYieldRequired != pdFALSE)
            {
                taskYIELD_IF_USING_PREEMPTION();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Remove compiler warning about unused variables when the port
            optimised task selection is not being used. */
            (void)uxPriorityUsedOnEntry;
        }
    }
    taskEXIT_CRITICAL();
}

#endif /* INCLUDE_vTaskPrioritySet */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskSuspend == 1)

void vTaskSuspend(TaskHandle_t xTaskToSuspend)
{
    TCB_t *pxTCB;

    /* 进入临界保护 */
    taskENTER_CRITICAL();
    {
        /* If null is passed in here then it is the running task that is
        being suspended. */
        /* 获取任务句柄 */
        pxTCB = prvGetTCBFromHandle(xTaskToSuspend);

        traceTASK_SUSPEND(pxTCB);

        /* Remove task from the ready/delayed list and place in the
        suspended list. */
        /* 从据需列表中移除 */
        if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
        {
            /* 如果移除后相应优先级没有任务就绪，恢复就绪队列 */
            taskRESET_READY_PRIORITY(pxTCB->uxPriority);
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /* Is the task waiting on an event also? */
        /* 如果任务在等待一个事件 */
        if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
        {
            /* 从事件链表中移除 */
            (void)uxListRemove(&(pxTCB->xEventListItem));
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /* 把任务加入到挂起的任务队列 */
        vListInsertEnd(&xSuspendedTaskList, &(pxTCB->xStateListItem));

#if (configUSE_TASK_NOTIFICATIONS == 1)
        {
            /* 如果任务还在等待通知 */
            if (pxTCB->ucNotifyState == taskWAITING_NOTIFICATION)
            {
                /* The task was blocked to wait for a notification, but is
                now suspended, so no notification was received. */
                /* 设置为不再等待 */
                pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
            }
        }
#endif
    }
    /* 退出临界保护 */
    taskEXIT_CRITICAL();

    /* 可以用调度器状态获取函数代替提高可读性，但是效率不高 */
    /* 如果调度器在运行 */
    if (xSchedulerRunning != pdFALSE)
    {
        /* Reset the next expected unblock time in case it referred to the
        task that is now in the Suspended state. */
        /* 进入临界保护 */
        taskENTER_CRITICAL();
        {
            /* 复位下一个解除阻塞的时间点 */
            prvResetNextTaskUnblockTime();
        }
        /* 退出临界保护 */
        taskEXIT_CRITICAL();
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* 如果需要挂起的是当前的任务 */
    if (pxTCB == pxCurrentTCB)
    {
        /* 可以用调度器状态获取函数代替提高可读性，但是效率不高 */
        /* 当调度器运行的时候 */
        if (xSchedulerRunning != pdFALSE)
        {
            /* The current task has just been suspended. */
            configASSERT(uxSchedulerSuspended == 0);
            /* 请求任务调度 */
            portYIELD_WITHIN_API();
        }
        else
        {
            /* The scheduler is not running, but the task that was pointed
            to by pxCurrentTCB has just been suspended and pxCurrentTCB
            must be adjusted to point to a different task. */
            /* 如果调度器不运行，并且当前的任务全都挂起了 */
            if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) == uxCurrentNumberOfTasks)
            {
                /* No other tasks are ready, so set pxCurrentTCB back to
                NULL so when the next task is created pxCurrentTCB will
                be set to point to it no matter what its relative priority
                is. */
                /* 当前的TCB指针指向空 */
                pxCurrentTCB = NULL;
            }
            else
            {
                /* 如果当前的任务没有全部挂起，那么执行上下文切换 */
                /* 实现的具体操作其实是pxCurrentTCB指向最高优先级的任务TCB */
                vTaskSwitchContext();
            }
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}

#endif /* INCLUDE_vTaskSuspend */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskSuspend == 1)

static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask)
{
    BaseType_t xReturn = pdFALSE;
    const TCB_t *const pxTCB = (TCB_t *)xTask;

    /* Accesses xPendingReadyList so must be called from a critical
    section. */

    /* It does not make sense to check if the calling task is suspended. */
    configASSERT(xTask);

    /* Is the task being resumed actually in the suspended list? */
    /* 首先查看一个有效任务是否在挂起的任务链表中，如果不在肯定没挂起 */
    if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) != pdFALSE)
    {
        /* Has the task already been resumed from within an ISR? */
        /* 如果任务已经在xPendingReadyList，说明ISR中将其进行了恢复 */
        if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) == pdFALSE)
        {
            /* Is it in the suspended list because it is in the	Suspended
            state, or because is is blocked with no timeout? */
            /*lint !e961.  The cast is only redundant when NULL is used. */
            /* 如果事件链表容器无效，那么说明这个任务跟事件无关，因此是挂起状态，否则不是 */
            if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) != pdFALSE)
            {
                xReturn = pdTRUE;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */

#endif /* INCLUDE_vTaskSuspend */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskSuspend == 1)

void vTaskResume(TaskHandle_t xTaskToResume)
{
    TCB_t *const pxTCB = (TCB_t *)xTaskToResume;

    /* It does not make sense to resume the calling task. */
    /* 不管是任务不存在还是唤醒自身都是无意义的 */
    configASSERT(xTaskToResume);

    /* The parameter cannot be NULL as it is impossible to resume the
    currently executing task. */
    /* 如果有效且不是当前的任务 */
    if ((pxTCB != NULL) && (pxTCB != pxCurrentTCB))
    {
        /* 任务状态的修改，需要进入中断保护 */
        taskENTER_CRITICAL();
        {
            /* 如果任务是挂起的状态 */
            if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE)
            {
                traceTASK_RESUME(pxTCB);

                /* The ready list can be accessed even if the scheduler is
                suspended because this is inside a critical section. */
                /* 从挂起的任务链表中删除，然后加入到就绪任务链表之中 */
                (void)uxListRemove(&(pxTCB->xStateListItem));
                prvAddTaskToReadyList(pxTCB);

                /* A higher priority task may have just been resumed. */
                /* 如果恢复的任务优先级高于当前的任务，需要有任务调度发生 */
                if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
                {
                    /* This yield may not cause the task just resumed to run,
                    but will leave the lists in the correct state for the
                    next yield. */
                    taskYIELD_IF_USING_PREEMPTION();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        /* 退出中断保护 */
        taskEXIT_CRITICAL();
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}

#endif /* INCLUDE_vTaskSuspend */

/*-----------------------------------------------------------*/

#if ((INCLUDE_xTaskResumeFromISR == 1) && (INCLUDE_vTaskSuspend == 1))

BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume)
{
    BaseType_t xYieldRequired = pdFALSE;
    TCB_t *const pxTCB = (TCB_t *)xTaskToResume;
    UBaseType_t uxSavedInterruptStatus;

    /* 跟系统级别的API一样，先判断 有效性 */
    configASSERT(xTaskToResume);

    /* 因为是在ISR中调用，因此不会跟系统级的API一样需要判断是否是当前任务 */

    /* RTOS ports that support interrupt nesting have the concept of a
    maximum	system call (or maximum API call) interrupt priority.
    Interrupts that are	above the maximum system call priority are keep
    permanently enabled, even when the RTOS kernel is in a critical section,
    but cannot make any calls to FreeRTOS API functions.  If configASSERT()
    is defined in FreeRTOSConfig.h then
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
    failure if a FreeRTOS API function is called from an interrupt that has
    been assigned a priority above the configured maximum system call
    priority.  Only FreeRTOS functions that end in FromISR can be called
    from interrupts	that have been assigned a priority at or (logically)
    below the maximum system call interrupt priority.  FreeRTOS maintains a
    separate interrupt safe API to ensure interrupt entry is as fast and as
    simple as possible.  More information (albeit Cortex-M specific) is
    provided on the following link:
    http://www.freertos.org/RTOS-Cortex-M3-M4.html */
    /* 确认中断优先级的有效性 */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    /* 临时屏蔽中断的发生 */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* 入果任务是挂起的状态 */
        if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE)
        {
            traceTASK_RESUME_FROM_ISR(pxTCB);

            /* Check the ready lists can be accessed. */
            /* 调度器如果没挂起 */
            if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
            {
                /* Ready lists can be accessed so move the task from the
                suspended list to the ready list directly. */
                /* 与前面的vTaskResume()接口实现一样 */
                if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
                {
                    xYieldRequired = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                (void)uxListRemove(&(pxTCB->xStateListItem));
                prvAddTaskToReadyList(pxTCB);
            }
            else
            {
                /* The delayed or ready lists cannot be accessed so the task
                is held in the pending ready list until the scheduler is
                unsuspended. */
                /* 如果调度器是挂起的，放到xPendingReadyList */
                vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    /* 恢复中断使能 */
    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);

    return xYieldRequired;
}

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

/* 综合看来，这个启动接口实现了idle task的创建、timer task的创建（可选）、初始化了一部分状态信息 */
/* 之后，执行了任务调度器启动的动作，但是启动的动作是一个黑盒封装。 */
void vTaskStartScheduler(void)
{
    BaseType_t xReturn;

    /* Add the idle task at the lowest priority. */
    /* 从这里看，配置了静态存储分配的支持之后，idle task的创建就是静态的模式了 */
#if (configSUPPORT_STATIC_ALLOCATION == 1)
    {
        StaticTask_t *pxIdleTaskTCBBuffer = NULL;
        StackType_t *pxIdleTaskStackBuffer = NULL;
        uint32_t ulIdleTaskStackSize;

        /* The Idle task is created using user provided RAM - obtain the
        address of the RAM then create the idle task. */
        /* 这么看，idle task的创建不会消耗FreeRTOS的heap空间 */
        /* 下面的结构，获取了idle task的TCB对象位置、堆栈位置及大小 */
        vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize);
        /* 获取了idle task的一些对象信息之后，以静态方式创建idle task。 */
        xIdleTaskHandle = xTaskCreateStatic(prvIdleTask,
                                            configIDLE_TASK_NAME,
                                            ulIdleTaskStackSize,
                                            /*lint !e961.  The cast is not redundant for all compilers. */
                                            (void *)NULL,
                                            (tskIDLE_PRIORITY | portPRIVILEGE_BIT),
                                            pxIdleTaskStackBuffer,
                                            /*lint !e961 MISRA exception, justified as it is not a redundant
                                             * explicit cast to all supported compilers. */
                                            pxIdleTaskTCBBuffer);

        /* 判断idle task是否创建成功 */
        if (xIdleTaskHandle != NULL)
        {
            xReturn = pdPASS;
        }
        else
        {
            xReturn = pdFAIL;
        }
    }
#else
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        /* 如果配置不支持静态的堆栈分配，那么以动态的形式创建idle task */
        /* 这么看，其实纯动态模式下，idle task是要占用FreeRTOS heap的。 */
        xReturn = xTaskCreate(prvIdleTask,
                              configIDLE_TASK_NAME,
                              configMINIMAL_STACK_SIZE,
                              (void *)NULL,
                              (tskIDLE_PRIORITY | portPRIVILEGE_BIT),
                              /*lint !e961 MISRA exception, justified as it is not a redundant
                               * explicit cast to all supported compilers. */
                              &xIdleTaskHandle);
    }
#endif /* configSUPPORT_STATIC_ALLOCATION */

    /* 目前没有使能timer，等后续使能之后再分析 */
#if (configUSE_TIMERS == 1)
    {
        if (xReturn == pdPASS)
        {
            xReturn = xTimerCreateTimerTask();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
#endif /* configUSE_TIMERS */

    /* 如果idle task创建成功 */
    if (xReturn == pdPASS)
    {
        /* freertos_tasks_c_additions_init() should only be called if the user
        definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
        the only macro called by the function. */
        /* 以下无效 */
#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
        {
            freertos_tasks_c_additions_init();
        }
#endif

        /* Interrupts are turned off here, to ensure a tick does not occur
        before or during the call to xPortStartScheduler().  The stacks of
        the created tasks contain a status word with interrupts switched on
        so interrupts will automatically get re-enabled when the first task
        starts to run. */
        /* 禁用中断，防止tick产生，不然前面的idle task已经其他已经创建好的task将会被调度处理 */
        portDISABLE_INTERRUPTS();

        /* 以下无效 */
#if (configUSE_NEWLIB_REENTRANT == 1)
        {
            /* Switch Newlib's _impure_ptr variable to point to the _reent
            structure specific to the task that will run first. */
            _impure_ptr = &(pxCurrentTCB->xNewLib_reent);
        }
#endif /* configUSE_NEWLIB_REENTRANT */

        /* 下一个任务的非阻塞时间？ */
        xNextTaskUnblockTime = portMAX_DELAY;
        /* 标注调度已经开启 */
        xSchedulerRunning = pdTRUE;
        /* tick的计数初始化为0 */
        xTickCount = (TickType_t)0U;

        /* If configGENERATE_RUN_TIME_STATS is defined then the following
        macro must be defined to configure the timer/counter used to generate
        the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
        is set to 0 and the following line fails to build then ensure you do not
        have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
        FreeRTOSConfig.h file. */
        /* 下面的接口当前定义为了空 */
        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

        /* Setting up the timer tick is hardware specific and thus in the
        portable interface. */
        /* 启动调度器，具体的操作内容后面再做分析 */
        if (xPortStartScheduler() != pdFALSE)
        {
            /* Should not reach here as if the scheduler is running the
            function will not return. */
        }
        else
        {
            /* Should only reach here if a task calls xTaskEndScheduler(). */
        }
    }
    else
    {
        /* 如果idle task创建失败 */
        /* This line will only be reached if the kernel could not be started,
        because there was not enough FreeRTOS heap to create the idle task
        or the timer task. */
        /* 如果失败，直接停留在断言位置 */
        configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    }

    /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
    meaning xIdleTaskHandle is not used anywhere else. */
    /* 防止编译警告出现 */
    (void)xIdleTaskHandle;
}
/*-----------------------------------------------------------*/

void vTaskEndScheduler(void)
{
    /* Stop the scheduler interrupts and call the portable scheduler end
    routine so the original ISRs can be restored if necessary.  The port
    layer must ensure interrupts enable	bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    /* 调度器停止标志设置 */
    xSchedulerRunning = pdFALSE;
    vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll(void)
{
    /* A critical section is not required as the variable is of type
    BaseType_t.  Please read Richard Barry's reply in the following link to a
    post in the FreeRTOS support forum before reporting this as a bug! -
    http://goo.gl/wu4acr */
    /* 标记有一次调度的挂起 */
    ++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

#if (configUSE_TICKLESS_IDLE != 0)

static TickType_t prvGetExpectedIdleTime(void)
{
    TickType_t xReturn;
    UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;

/* uxHigherPriorityReadyTasks takes care of the case where
configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
task that are in the Ready state, even though the idle task is
running. */
#if (configUSE_PORT_OPTIMISED_TASK_SELECTION == 0)
    {
        if (uxTopReadyPriority > tskIDLE_PRIORITY)
        {
            uxHigherPriorityReadyTasks = pdTRUE;
        }
    }
#else
    {
        const UBaseType_t uxLeastSignificantBit = (UBaseType_t)0x01;

        /* When port optimised task selection is used the uxTopReadyPriority
        variable is used as a bit map.  If bits other than the least
        significant bit are set then there are tasks that have a priority
        above the idle priority that are in the Ready state.  This takes
        care of the case where the co-operative scheduler is in use. */
        if (uxTopReadyPriority > uxLeastSignificantBit)
        {
            uxHigherPriorityReadyTasks = pdTRUE;
        }
    }
#endif

    if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY)
    {
        xReturn = 0;
    }
    else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > 1)
    {
        /* There are other idle priority tasks in the ready state.  If
        time slicing is used then the very next tick interrupt must be
        processed. */
        xReturn = 0;
    }
    else if (uxHigherPriorityReadyTasks != pdFALSE)
    {
        /* There are tasks in the Ready state that have a priority above the
        idle priority.  This path can only be reached if
        configUSE_PREEMPTION is 0. */
        xReturn = 0;
    }
    else
    {
        xReturn = xNextTaskUnblockTime - xTickCount;
    }

    return xReturn;
}

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

/* 这个接口是默认就需要提供的接口 */
BaseType_t xTaskResumeAll(void)
{
    TCB_t *pxTCB = NULL;
    BaseType_t xAlreadyYielded = pdFALSE;

    /* If uxSchedulerSuspended is zero then this function does not match a
    previous call to vTaskSuspendAll(). */
    /* 调度器不能够是挂起的状态 */
    configASSERT(uxSchedulerSuspended);

    /* It is possible that an ISR caused a task to be removed from an event
    list while the scheduler was suspended.  If this was the case then the
    removed task will have been added to the xPendingReadyList.  Once the
    scheduler has been resumed it is safe to move all the pending ready
    tasks from this list into their appropriate ready list. */
    /* 涉及到任务链表等状态的修改，加中断保护 */
    taskENTER_CRITICAL();
    {
        /* 这个接口与挂起全部的任务是一个相反的处理，而挂起的时候下面的量++ */
        /* 这里其实是做了一个逆向的操作 */
        --uxSchedulerSuspended;

        /* 调度器如果没有挂起 */
        if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
        {
            /* 当前的任务数目大于0 */
            if (uxCurrentNumberOfTasks > (UBaseType_t)0U)
            {
                /* Move any readied tasks from the pending list into the
                appropriate ready list. */
                /* 挂起任务链表xPendingReadyList只要不是空的就一直处理，直到为空 */
                while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE)
                {
                    /* 获取链表第一个节点的TCB指针 */
                    pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
                    /* 从事件链表中移除 */
                    (void)uxListRemove(&(pxTCB->xEventListItem));
                    /* 从状态链表中移除 */
                    (void)uxListRemove(&(pxTCB->xStateListItem));
                    /* 加入到就绪任务链表 */
                    prvAddTaskToReadyList(pxTCB);

                    /* If the moved task has a priority higher than the current
                    task then a yield must be performed. */
                    /* 恢复的任务中只要有一个优先级高于当前就需要请求任务调度 */
                    if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
                    {
                        xYieldPending = pdTRUE;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                /* 下面的条件成立说明有任务在挂起的状态 */
                if (pxTCB != NULL)
                {
                    /* A task was unblocked while the scheduler was suspended,
                    which may have prevented the next unblock time from being
                    re-calculated, in which case re-calculate it now.  Mainly
                    important for low power tickless implementations, where
                    this can prevent an unnecessary exit from low power
                    state. */
                    /* 复位下一次的阻塞解除时间 */
                    prvResetNextTaskUnblockTime();
                }

                /* If any ticks occurred while the scheduler was suspended then
                they should be processed now.  This ensures the tick count does
                not	slip, and that any delayed tasks are resumed at the correct
                time. */
                {
                    /* 之前分析过uxPendedTicks，可能是需要追加的调度次数 */
                    UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */

                    /* 下面的逻辑其实就是调度追加的处理 */
                    if (uxPendedCounts > (UBaseType_t)0U)
                    {
                        do
                        {
                            if (xTaskIncrementTick() != pdFALSE)
                            {
                                /* tick处理只是处理任务链表，并不会进行任务调度的处理，因此状态保留 */
                                xYieldPending = pdTRUE;
                            }
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                            --uxPendedCounts;
                        } while (uxPendedCounts > (UBaseType_t)0U);

                        uxPendedTicks = 0;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                /* 如果需要调度，那么执行调度 */
                if (xYieldPending != pdFALSE)
                {
#if (configUSE_PREEMPTION != 0)
                    {
                        xAlreadyYielded = pdTRUE;
                    }
#endif
                    taskYIELD_IF_USING_PREEMPTION();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();

    return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

/* 获取当前的tick数值 */
TickType_t xTaskGetTickCount(void)
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    /* 进入临界保护，然后做一个数据的备份 */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
    }
    /* 退出临界保护之后反馈备份数值 */
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
}
/*-----------------------------------------------------------*/

/* 从ISR中获取tick数值 */
/* 如果是从tick ISR中做获取，其实只要ISR不超时问题不大。但是，这种处理通常意义不大 */
TickType_t xTaskGetTickCountFromISR(void)
{
    TickType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    /* RTOS ports that support interrupt nesting have the concept of a maximum
    system call (or maximum API call) interrupt priority.  Interrupts that are
    above the maximum system call priority are kept permanently enabled, even
    when the RTOS kernel is in a critical section, but cannot make any calls to
    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
    then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
    failure if a FreeRTOS API function is called from an interrupt that has been
    assigned a priority above the configured maximum system call priority.
    Only FreeRTOS functions that end in FromISR can be called from interrupts
    that have been assigned a priority at or (logically) below the maximum
    system call	interrupt priority.  FreeRTOS maintains a separate interrupt
    safe API to ensure interrupt entry is as fast and as simple as possible.
    More information (albeit Cortex-M specific) is provided on the following
    link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
    /* 判断中断优先级是否合法 */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    /* 设置中断掩码屏蔽OS管理下的中断发生 */
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        /* 保存tick的临时副本 */
        xReturn = xTickCount;
    }
    /* 恢复之前的中断掩码 */
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);

    return xReturn;
}
/*-----------------------------------------------------------*/

/* 这个任务数的变量增加其实是在把新的任务加入就绪任务链表的时候进行增加操作 */
/* 既然是新的任务，也就是伴随着每一个任务的产生创建过程，正好记录了系统中任务的数目 */
UBaseType_t uxTaskGetNumberOfTasks(void)
{
    /* A critical section is not required because the variables are of type
    BaseType_t. */
    return uxCurrentNumberOfTasks;
}
/*-----------------------------------------------------------*/

/* 获取任务的名称 */
/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
char *pcTaskGetName(TaskHandle_t xTaskToQuery)
{
    TCB_t *pxTCB;

    /* If null is passed in here then the name of the calling task is being
    queried. */
    /* 通过任务的句柄获取相关任务的TCB指针 */
    /* 在这个获取的过程中做了一个转换，如果传入的指针为NULL那么将会处理当前的任务 */
    pxTCB = prvGetTCBFromHandle(xTaskToQuery);
    /* 任务TCB必须有效 */
    configASSERT(pxTCB);
    /* 查询到的信息其实是任务吗字符串开始的位置 */
    return &(pxTCB->pcTaskName[0]);
}

/*-----------------------------------------------------------*/

#if (INCLUDE_xTaskGetHandle == 1)

static TCB_t *prvSearchForNameWithinSingleList(List_t *pxList, const char pcNameToQuery[])
{
    TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
    UBaseType_t x;
    char cNextChar;

    /* This function is called with the scheduler suspended. */

    if (listCURRENT_LIST_LENGTH(pxList) > (UBaseType_t)0)
    {
        listGET_OWNER_OF_NEXT_ENTRY(pxFirstTCB, pxList);

        do
        {
            listGET_OWNER_OF_NEXT_ENTRY(pxNextTCB, pxList);

            /* Check each character in the name looking for a match or
            mismatch. */
            for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++)
            {
                cNextChar = pxNextTCB->pcTaskName[x];

                if (cNextChar != pcNameToQuery[x])
                {
                    /* Characters didn't match. */
                    break;
                }
                else if (cNextChar == 0x00)
                {
                    /* Both strings terminated, a match must have been
                    found. */
                    pxReturn = pxNextTCB;
                    break;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            if (pxReturn != NULL)
            {
                /* The handle has been found. */
                break;
            }

        } while (pxNextTCB != pxFirstTCB);
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return pxReturn;
}

#endif /* INCLUDE_xTaskGetHandle */
/*-----------------------------------------------------------*/

#if (INCLUDE_xTaskGetHandle == 1)

TaskHandle_t xTaskGetHandle(const char *pcNameToQuery) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    UBaseType_t uxQueue = configMAX_PRIORITIES;
    TCB_t *pxTCB;

    /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
    configASSERT(strlen(pcNameToQuery) < configMAX_TASK_NAME_LEN);

    vTaskSuspendAll();
    {
        /* Search the ready lists. */
        do
        {
            uxQueue--;
            pxTCB = prvSearchForNameWithinSingleList((List_t *)&(pxReadyTasksLists[uxQueue]), pcNameToQuery);

            if (pxTCB != NULL)
            {
                /* Found the handle. */
                break;
            }

        } while (uxQueue > (UBaseType_t)tskIDLE_PRIORITY); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

        /* Search the delayed lists. */
        if (pxTCB == NULL)
        {
            pxTCB = prvSearchForNameWithinSingleList((List_t *)pxDelayedTaskList, pcNameToQuery);
        }

        if (pxTCB == NULL)
        {
            pxTCB = prvSearchForNameWithinSingleList((List_t *)pxOverflowDelayedTaskList, pcNameToQuery);
        }

#if (INCLUDE_vTaskSuspend == 1)
        {
            if (pxTCB == NULL)
            {
                /* Search the suspended list. */
                pxTCB = prvSearchForNameWithinSingleList(&xSuspendedTaskList, pcNameToQuery);
            }
        }
#endif

#if (INCLUDE_vTaskDelete == 1)
        {
            if (pxTCB == NULL)
            {
                /* Search the deleted list. */
                pxTCB = prvSearchForNameWithinSingleList(&xTasksWaitingTermination, pcNameToQuery);
            }
        }
#endif
    }
    (void)xTaskResumeAll();

    return (TaskHandle_t)pxTCB;
}

#endif /* INCLUDE_xTaskGetHandle */
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

UBaseType_t uxTaskGetSystemState(TaskStatus_t *const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t *const pulTotalRunTime)
{
    UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;

    vTaskSuspendAll();
    {
        /* Is there a space in the array for each task in the system? */
        if (uxArraySize >= uxCurrentNumberOfTasks)
        {
            /* Fill in an TaskStatus_t structure with information on each
            task in the Ready state. */
            do
            {
                uxQueue--;
                uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), &(pxReadyTasksLists[uxQueue]), eReady);

            } while (uxQueue > (UBaseType_t)tskIDLE_PRIORITY); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

            /* Fill in an TaskStatus_t structure with information on each
            task in the Blocked state. */
            uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), (List_t *)pxDelayedTaskList, eBlocked);
            uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), (List_t *)pxOverflowDelayedTaskList, eBlocked);

#if (INCLUDE_vTaskDelete == 1)
            {
                /* Fill in an TaskStatus_t structure with information on
                each task that has been deleted but not yet cleaned up. */
                uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), &xTasksWaitingTermination, eDeleted);
            }
#endif

#if (INCLUDE_vTaskSuspend == 1)
            {
                /* Fill in an TaskStatus_t structure with information on
                each task in the Suspended state. */
                uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), &xSuspendedTaskList, eSuspended);
            }
#endif

#if (configGENERATE_RUN_TIME_STATS == 1)
            {
                if (pulTotalRunTime != NULL)
                {
#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                    portALT_GET_RUN_TIME_COUNTER_VALUE((*pulTotalRunTime));
#else
                    *pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
#endif
                }
            }
#else
            {
                if (pulTotalRunTime != NULL)
                {
                    *pulTotalRunTime = 0;
                }
            }
#endif
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    (void)xTaskResumeAll();

    return uxTask;
}

#endif /* configUSE_TRACE_FACILITY */
/*----------------------------------------------------------*/

#if (INCLUDE_xTaskGetIdleTaskHandle == 1)

TaskHandle_t xTaskGetIdleTaskHandle(void)
{
    /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
    started, then xIdleTaskHandle will be NULL. */
    configASSERT((xIdleTaskHandle != NULL));
    return xIdleTaskHandle;
}

#endif /* INCLUDE_xTaskGetIdleTaskHandle */
/*----------------------------------------------------------*/

/* This conditional compilation should use inequality to 0, not equality to 1.
This is to ensure vTaskStepTick() is available when user defined low power mode
implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1. */
/* 当前的软件工程中，下面的这些代码无效 */
#if (configUSE_TICKLESS_IDLE != 0)

void vTaskStepTick(const TickType_t xTicksToJump)
{
    /* Correct the tick count value after a period during which the tick
    was suppressed.  Note this does *not* call the tick hook function for
    each stepped tick. */
    configASSERT((xTickCount + xTicksToJump) <= xNextTaskUnblockTime);
    xTickCount += xTicksToJump;
    traceINCREASE_TICK_COUNT(xTicksToJump);
}

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

#if (INCLUDE_xTaskAbortDelay == 1)

BaseType_t xTaskAbortDelay(TaskHandle_t xTask)
{
    TCB_t *pxTCB = (TCB_t *)xTask;
    BaseType_t xReturn;

    configASSERT(pxTCB);

    vTaskSuspendAll();
    {
        /* A task can only be prematurely removed from the Blocked state if
        it is actually in the Blocked state. */
        if (eTaskGetState(xTask) == eBlocked)
        {
            xReturn = pdPASS;

            /* Remove the reference to the task from the blocked list.  An
            interrupt won't touch the xStateListItem because the
            scheduler is suspended. */
            (void)uxListRemove(&(pxTCB->xStateListItem));

            /* Is the task waiting on an event also?  If so remove it from
            the event list too.  Interrupts can touch the event list item,
            even though the scheduler is suspended, so a critical section
            is used. */
            taskENTER_CRITICAL();
            {
                if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
                {
                    (void)uxListRemove(&(pxTCB->xEventListItem));
                    pxTCB->ucDelayAborted = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();

            /* Place the unblocked task into the appropriate ready list. */
            prvAddTaskToReadyList(pxTCB);

/* A task being unblocked cannot cause an immediate context
switch if preemption is turned off. */
#if (configUSE_PREEMPTION == 1)
            {
                /* Preemption is on, but a context switch should only be
                performed if the unblocked task has a priority that is
                equal to or higher than the currently executing task. */
                if (pxTCB->uxPriority > pxCurrentTCB->uxPriority)
                {
                    /* Pend the yield to be performed when the scheduler
                    is unsuspended. */
                    xYieldPending = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
#endif /* configUSE_PREEMPTION */
        }
        else
        {
            xReturn = pdFAIL;
        }
    }
    (void)xTaskResumeAll();

    return xReturn;
}

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick(void)
{
    TCB_t *pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;

    /* Called by the portable layer each time a tick interrupt occurs.
    Increments the tick then checks to see if the new tick value will cause any
    tasks to be unblocked. */
    /* 下面这个接口无效 */
    traceTASK_INCREMENT_TICK(xTickCount);
    /* 如果调度器没有挂起 */
    if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
    {
        /* 下面的2步操作其实是给xTickCount增加 1，为什么中间必须周转一下？ */
        /* Minor optimisation.  The tick count cannot change in this
        block. */
        const TickType_t xConstTickCount = xTickCount + (TickType_t)1;

        /* Increment the RTOS tick, switching the delayed and overflowed
        delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
        /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
        /* 如果出现了溢出，那么需要切换延迟的链表。这么看，这个tick数值以及变化趋势可能是
         * 调度执行的参考信息 */
        if (xConstTickCount == (TickType_t)0U)
        {
            taskSWITCH_DELAYED_LISTS();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /* See if this tick has made a timeout expire.  Tasks are stored in
        the	queue in the order of their wake time - meaning once one task
        has been found whose block time has not expired there is no need to
        look any further down the list. */
        /* 如果tick的数值有达到唤醒时间的，那么需要进行调度。这样，xNextTaskUnblockTime
         * 的意义也顺便明确了。这个数值其实是最近的一个唤醒时间tick数值。 */
        if (xConstTickCount >= xNextTaskUnblockTime)
        {
            for (;;)
            {
                /* 如果没有delay的task */
                if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE)
                {
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                    to the maximum possible value so it is extremely
                    unlikely that the
                    if( xTickCount >= xNextTaskUnblockTime ) test will pass
                    next time through. */
                    /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                    /* 下一次的任务唤醒点设置的远一些 */
                    xNextTaskUnblockTime = portMAX_DELAY;
                    break;
                }
                else
                {
                    /* The delayed list is not empty, get the value of the
                    item at the head of the delayed list.  This is the time
                    at which the task at the head of the delayed list must
                    be removed from the Blocked state. */
                    /* 如果有延迟的任务，找到相应的任务的唤醒点数值 */
                    pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
                    xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));

                    if (xConstTickCount < xItemValue)
                    {
                        /* It is not time to unblock this item yet, but the
                        item value is the time at which the task at the head
                        of the blocked list must be removed from the Blocked
                        state -	so record the item value in
                        xNextTaskUnblockTime. */
                        /* 从这一段描述看，其实这个delay的概念可能是还没来得及处理，不见得一定延期 */
                        xNextTaskUnblockTime = xItemValue;
                        break;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    /* 从链表中移除这个任务元素 */
                    (void)uxListRemove(&(pxTCB->xStateListItem));

                    /* Is the task waiting on an event also?  If so remove
                    it from the event list. */
                    /* 如果任务在等待事件，从事件链表中移除 */
                    if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
                    {
                        (void)uxListRemove(&(pxTCB->xEventListItem));
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                    list. */
                    /* 之后，加入到任务就绪链表。从这部分操作看，可能delay只是等待被处理的概念。
                     * 而事件的处理很可能也是转换成了tick计数信息来处理的 */
                    prvAddTaskToReadyList(pxTCB);

/* A task being unblocked cannot cause an immediate
context switch if preemption is turned off. */
#if (configUSE_PREEMPTION == 1)
                    {
                        /* Preemption is on, but a context switch should
                        only be performed if the unblocked task has a
                        priority that is equal to or higher than the
                        currently executing task. */
                        if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
                        {
                            xSwitchRequired = pdTRUE;
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
#endif /* configUSE_PREEMPTION */
                }
            }
        }

/* Tasks of equal priority to the currently running task will share
processing time (time slice) if preemption is on, and the application
writer has not explicitly turned time slicing off. */
    /* 软件执行到这里，一定是有一个任务就绪了。如果支持抢占和时间片，下面成立。 */
    /* 目前，我所处理的这个工程是满足预处理的条件的。 */
#if ((configUSE_PREEMPTION == 1) && (configUSE_TIME_SLICING == 1))
        {
            /* 如果当前（优先级）任务链表的长度大于1，说明多个任务ready，执行切换请求 */
            if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1)
            {
                xSwitchRequired = pdTRUE;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */

    /* 目前的配置中，下面的代码无效 */
#if (configUSE_TICK_HOOK == 1)
        {
            /* Guard against the tick hook being called when the pended tick
            count is being unwound (when the scheduler is being unlocked). */
            if (uxPendedTicks == (UBaseType_t)0U)
            {
                vApplicationTickHook();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
#endif /* configUSE_TICK_HOOK */
    }
    else
    {
        /* 如果调度器挂起了，增加一个挂起的计数器 */
        /* 这个计数的作用应该是要提示调度器接下来要追加调度次数 */
        ++uxPendedTicks;

/* The tick hook gets called at regular intervals, even if the
scheduler is locked. */
    /* 目前的配置中，下面的代码无效 */
#if (configUSE_TICK_HOOK == 1)
        {
            vApplicationTickHook();
        }
#endif
    }

#if (configUSE_PREEMPTION == 1)
    {
        /* 如果有调度请求，切换请求使能 */
        if (xYieldPending != pdFALSE)
        {
            xSwitchRequired = pdTRUE;
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
#endif /* configUSE_PREEMPTION */

    /* 最终任务切换请求是被当做返回值来提供出来的，因此这个结果应该是一个调度的判断依据 */
    return xSwitchRequired;
}
/*-----------------------------------------------------------*/

#if (configUSE_APPLICATION_TASK_TAG == 1)

void vTaskSetApplicationTaskTag(TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)
{
    TCB_t *xTCB;

    /* If xTask is NULL then it is the task hook of the calling task that is
    getting set. */
    if (xTask == NULL)
    {
        xTCB = (TCB_t *)pxCurrentTCB;
    }
    else
    {
        xTCB = (TCB_t *)xTask;
    }

    /* Save the hook function in the TCB.  A critical section is required as
    the value can be accessed from an interrupt. */
    taskENTER_CRITICAL();
    xTCB->pxTaskTag = pxHookFunction;
    taskEXIT_CRITICAL();
}

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if (configUSE_APPLICATION_TASK_TAG == 1)

TaskHookFunction_t xTaskGetApplicationTaskTag(TaskHandle_t xTask)
{
    TCB_t *xTCB;
    TaskHookFunction_t xReturn;

    /* If xTask is NULL then we are setting our own task hook. */
    if (xTask == NULL)
    {
        xTCB = (TCB_t *)pxCurrentTCB;
    }
    else
    {
        xTCB = (TCB_t *)xTask;
    }

    /* Save the hook function in the TCB.  A critical section is required as
    the value can be accessed from an interrupt. */
    taskENTER_CRITICAL();
    {
        xReturn = xTCB->pxTaskTag;
    }
    taskEXIT_CRITICAL();

    return xReturn;
}

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if (configUSE_APPLICATION_TASK_TAG == 1)

BaseType_t xTaskCallApplicationTaskHook(TaskHandle_t xTask, void *pvParameter)
{
    TCB_t *xTCB;
    BaseType_t xReturn;

    /* If xTask is NULL then we are calling our own task hook. */
    if (xTask == NULL)
    {
        xTCB = (TCB_t *)pxCurrentTCB;
    }
    else
    {
        xTCB = (TCB_t *)xTask;
    }

    if (xTCB->pxTaskTag != NULL)
    {
        xReturn = xTCB->pxTaskTag(pvParameter);
    }
    else
    {
        xReturn = pdFAIL;
    }

    return xReturn;
}

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext(void)
{
    /* 如果 uxSchedulerSuspended 不是 pdFALSE（其实是判断是否为0） */
    if (uxSchedulerSuspended != (UBaseType_t)pdFALSE)
    {
        /* The scheduler is currently suspended - do not allow a context
           switch. */
        /* 说明调度器是挂起的，此时修改下面的标志位用以指示需要进行上下文切换 */
        /* Yield是一个意思很多的单词，在OS中我理解这个应该是让步的意思。 */
        /* 因此，下面标志的语义应该是： 如果调度器还在挂起状态，那么让步调度操作 PENDING等待 */
        xYieldPending = pdTRUE;
    }
    else
    {
        /* 如果调度器没有挂起，那么执行上下文切换 */
        xYieldPending = pdFALSE;
        /* 下面的接口为空 */
        traceTASK_SWITCHED_OUT();

        /* 下面的条件不成立，不执行，但是从这里得到一个信息：时间统计是在上下文切换的时候处理的 */
#if (configGENERATE_RUN_TIME_STATS == 1)
        {
#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
            portALT_GET_RUN_TIME_COUNTER_VALUE(ulTotalRunTime);
#else
            ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
#endif

            /* Add the amount of time the task has been running to the
               accumulated time so far.  The time the task started running was
               stored in ulTaskSwitchedInTime.  Note that there is no overflow
               protection here so count values are only valid until the timer
               overflows.  The guard against negative values is to protect
               against suspect run time stat counter implementations - which
               are provided by the application, not the kernel. */
            if (ulTotalRunTime > ulTaskSwitchedInTime)
            {
                pxCurrentTCB->ulRunTimeCounter += (ulTotalRunTime - ulTaskSwitchedInTime);
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
            ulTaskSwitchedInTime = ulTotalRunTime;
        }
#endif /* configGENERATE_RUN_TIME_STATS */

        /* Check for stack overflow, if configured. */
        /* 堆栈溢出的处理功能目前没有开启，这里无效 */
        taskCHECK_FOR_STACK_OVERFLOW();

        /* Select a new task to run using either the generic C or port
           optimised asm code. */
        /* 接下来，选择高优先的任务进行切换 */
        taskSELECT_HIGHEST_PRIORITY_TASK();
        traceTASK_SWITCHED_IN();

        /* 下面的条件不成立 */
#if (configUSE_NEWLIB_REENTRANT == 1)
        {
            /* Switch Newlib's _impure_ptr variable to point to the _reent
               structure specific to this task. */
            _impure_ptr = &(pxCurrentTCB->xNewLib_reent);
        }
#endif /* configUSE_NEWLIB_REENTRANT */
    }
}
/*-----------------------------------------------------------*/

/* 从整个OS的实现看，下面的这个接口旨在队列实现的时候用到了 */
void vTaskPlaceOnEventList(List_t *const pxEventList, const TickType_t xTicksToWait)
{
    /* 首先得确保事件任务链表存在 */
    configASSERT(pxEventList);

    /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
    SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */

    /* Place the event list item of the TCB in the appropriate event list.
    This is placed in the list in priority order so the highest priority task
    is the first to be woken by the event.  The queue that contains the event
    list is locked, preventing simultaneous access from interrupts. */
    /* 当前任务通过事件链表元素成员加入到事件任务链表 */
    /* 这个加入的过程中有一个排序的操作 */
    vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));

    /* 之后，把当前的任务加入到 delayed task链表之中 */
    prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList(List_t *pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
    /* 首先得确保事件任务链表存在 */
    configASSERT(pxEventList);

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
    the event groups implementation. */
    /* 这个接口主要是用在调度器挂起的时候，因此不需要做排序也就可以理解了 */
    configASSERT(uxSchedulerSuspended != 0);

    /* Store the item value in the event list item.  It is safe to access the
    event list item here as interrupts won't access the event list item of a
    task that is not in the Blocked state. */
    /* 修改链表元素的数值，bit15设置为1 */
    listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xEventListItem), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE);

    /* Place the event list item of the TCB at the end of the appropriate event
    list.  It is safe to access the event list here because it is part of an
    event group implementation - and interrupts don't access event groups
    directly (instead they access them indirectly by pending function calls to
    the task level). */
    /* 当前的任务利用事件链表元素关联插入到事件链表的最后 */
    vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));

    /* 最后把当前的任务加入到 delayed task链表之中 */
    prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
}
/*-----------------------------------------------------------*/

#if (configUSE_TIMERS == 1)

void vTaskPlaceOnEventListRestricted(List_t *const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
    configASSERT(pxEventList);

    /* This function should not be called by application code hence the
    'Restricted' in its name.  It is not part of the public API.  It is
    designed for use by kernel code, and has special calling requirements -
    it should be called with the scheduler suspended. */

    /* Place the event list item of the TCB in the appropriate event list.
    In this case it is assume that this is the only task that is going to
    be waiting on this event list, so the faster vListInsertEnd() function
    can be used in place of vListInsert. */
    vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));

    /* If the task should block indefinitely then set the block time to a
    value that will be recognised as an indefinite delay inside the
    prvAddCurrentTaskToDelayedList() function. */
    if (xWaitIndefinitely != pdFALSE)
    {
        xTicksToWait = portMAX_DELAY;
    }

    traceTASK_DELAY_UNTIL((xTickCount + xTicksToWait));
    prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
}

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList)
{
    TCB_t *pxUnblockedTCB;
    BaseType_t xReturn;

    /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
    called from a critical section within an ISR. */

    /* The event list is sorted in priority order, so the first in the list can
    be removed as it is known to be the highest priority.  Remove the TCB from
    the delayed list, and add it to the ready list.

    If an event is for a queue that is locked then this function will never
    get called - the lock count on the queue will get modified instead.  This
    means exclusive access to the event list is guaranteed here.

    This function assumes that a check has already been made to ensure that
    pxEventList is not empty. */
    /* 获取事件链表首元素相关的TCB指针 */
    pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    configASSERT(pxUnblockedTCB);
    /* 从事件链表中移除首元素，解绑相关任务，队列剩余元素个数无关紧要 */
    (void)uxListRemove(&(pxUnblockedTCB->xEventListItem));

    /* 如果调度器没挂起 */
    if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
    {
        /* 把相关的任务加入到就绪任务链表之中 */
        (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
        prvAddTaskToReadyList(pxUnblockedTCB);
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
        pending until the scheduler is resumed. */
        /* 如果调度器挂起了，任务转移到 Pending Ready  list 中 */
        vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    }

    /* 如果就绪的任务优先级高于当前任务优先级，不管调度期是否运行都标注后续追加一次调度 */
    if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority)
    {
        /* Return true if the task removed from the event list has a higher
        priority than the calling task.  This allows the calling task to know if
        it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
        "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    }
    else
    {
        xReturn = pdFALSE;
    }

#if (configUSE_TICKLESS_IDLE != 0)
    {
        /* If a task is blocked on a kernel object then xNextTaskUnblockTime
        might be set to the blocked task's time out time.  If the task is
        unblocked for a reason other than a timeout xNextTaskUnblockTime is
        normally left unchanged, because it is automatically reset to a new
        value when the tick count equals xNextTaskUnblockTime.  However if
        tickless idling is used it might be more important to enter sleep mode
        at the earliest possible time - so reset xNextTaskUnblockTime here to
        ensure it is updated at the earliest possible time. */
        prvResetNextTaskUnblockTime();
    }
#endif

    /* 根据前面的代码分析，返回值其实是表征了是否有任务调度的需求 */

    return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList(ListItem_t *pxEventListItem, const TickType_t xItemValue)
{
    TCB_t *pxUnblockedTCB;

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
    the event flags implementation. */
    /* 这个主要是用于调度器挂起的时候，在此做了判断 */
    configASSERT(uxSchedulerSuspended != pdFALSE);

    /* Store the new item value in the event list. */
    /* 修改链表元素的数值，bit15设置为1 */
    listSET_LIST_ITEM_VALUE(pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE);

    /* Remove the event list form the event flag.  Interrupts do not access
    event flags. */
    /* 获取相应的任务TCB指针，之后将任务从事件链表中移除 */
    pxUnblockedTCB = (TCB_t *)listGET_LIST_ITEM_OWNER(pxEventListItem);
    configASSERT(pxUnblockedTCB);
    (void)uxListRemove(pxEventListItem);

    /* Remove the task from the delayed list and add it to the ready list.  The
    scheduler is suspended so interrupts will not be accessing the ready
    lists. */
    /* 加入到就绪任务链表之中 */
    (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
    prvAddTaskToReadyList(pxUnblockedTCB);

    /* 优先级如果高于当前的任务优先级，需要请求任务调度 */
    if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority)
    {
        /* The unblocked task has a priority above that of the calling task, so
        a context switch is required.  This function is called with the
        scheduler suspended so xYieldPending is set so the context switch
        occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    }
}
/*-----------------------------------------------------------*/

/* 设置超时状态，其实是获取两个状态信息 */
/* TimeOut_t有两个成员，一个是溢出技术，另一个是进入时间 */
void vTaskSetTimeOutState(TimeOut_t *const pxTimeOut)
{
    configASSERT(pxTimeOut);
    /* 进入中断保护 */
    taskENTER_CRITICAL();
    {
        /* 更新两个成员状态 */
        pxTimeOut->xOverflowCount = xNumOfOverflows;
        pxTimeOut->xTimeOnEntering = xTickCount;
    }
    /* 退出中断保护 */
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

/* 与上面的接口实现的功能相似，但是不用中断保护 */
void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut)
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

/* 检查超时 */
BaseType_t xTaskCheckForTimeOut(TimeOut_t *const pxTimeOut, TickType_t *const pxTicksToWait)
{
    BaseType_t xReturn;

    configASSERT(pxTimeOut);
    configASSERT(pxTicksToWait);

    /* 进入中断保护 */
    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        /* 从语义上看，其实这个只是多了一个中间量 */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;

        /* 以下部分无效 */
#if (INCLUDE_xTaskAbortDelay == 1)
        if (pxCurrentTCB->ucDelayAborted != pdFALSE)
        {
            /* The delay was aborted, which is not the same as a time out,
            but has the same result. */
            pxCurrentTCB->ucDelayAborted = pdFALSE;
            xReturn = pdTRUE;
        }
        else
#endif

#if (INCLUDE_vTaskSuspend == 1)
        /* 如果等待事件设置为极大值，任务会一直处于阻塞状态，不会出现超时 */
        /* 由此，超时其实是阻塞时间超过了之前指定的时间 */
        if (*pxTicksToWait == portMAX_DELAY)
        {
            /* If INCLUDE_vTaskSuspend is set to 1 and the block time
            specified is the maximum block time then the task should block
            indefinitely, and therefore never time out. */
            xReturn = pdFALSE;
        }
        else
#endif

        /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
        /* xNumOfOverflows之前分析过，其实是Tick的计数器溢出之后增加一次，因此，这里是检查这个数值是否
         发生了变化。如果发生了变化，并且调用接口的时候tick的计数器大于xTimeOnEntering下面的条件成立。
         而xTimeOnEntering是前面做超时检查的时候会更新的。目前，这个接口也是在队列中应用的。 */
        if ((xNumOfOverflows != pxTimeOut->xOverflowCount) && (xConstTickCount >= pxTimeOut->xTimeOnEntering))
        {
            /* The tick count is greater than the time at which
            vTaskSetTimeout() was called, but has also overflowed since
            vTaskSetTimeOut() was called.  It must have wrapped all the way
            around and gone past again. This passed since vTaskSetTimeout()
            was called. */
            xReturn = pdTRUE;
        }
        /*lint !e961 Explicit casting is only redundant with some compilers, 
        whereas others require it to prevent integer conversion errors. */
        /* 如果经过的时间小于传入的等待事件 */
        else if (xElapsedTime < *pxTicksToWait)
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            /* 等待的时间已经过了一段时间，但是不超时 */
            *pxTicksToWait -= xElapsedTime;
            /* 更新超时状态 */
            vTaskInternalSetTimeOutState(pxTimeOut);
            xReturn = pdFALSE;
        }
        else
        {
            /* 等待时间到了 */
            *pxTicksToWait = 0;
            xReturn = pdTRUE;
        }
    }
    /* 退出关键保护 */
    taskEXIT_CRITICAL();

    return xReturn;
}
/*-----------------------------------------------------------*/

/* 有调度没执行，这个接口是一个设置接口而不是查询接口 */
void vTaskMissedYield(void)
{
    xYieldPending = pdTRUE;
}
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

UBaseType_t uxTaskGetTaskNumber(TaskHandle_t xTask)
{
    UBaseType_t uxReturn;
    TCB_t *pxTCB;

    if (xTask != NULL)
    {
        pxTCB = (TCB_t *)xTask;
        uxReturn = pxTCB->uxTaskNumber;
    }
    else
    {
        uxReturn = 0U;
    }

    return uxReturn;
}

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

void vTaskSetTaskNumber(TaskHandle_t xTask, const UBaseType_t uxHandle)
{
    TCB_t *pxTCB;

    if (xTask != NULL)
    {
        pxTCB = (TCB_t *)xTask;
        pxTCB->uxTaskNumber = uxHandle;
    }
}

#endif /* configUSE_TRACE_FACILITY */

/*
 * -----------------------------------------------------------
 * The Idle task.
 * ----------------------------------------------------------
 *
 * The portTASK_FUNCTION() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for this function is:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
/* portTASK_FUNCTION,上面的注释中有这个的等效展开形式 */
/* 如下定了系统的idle Task */
static portTASK_FUNCTION(prvIdleTask, pvParameters)
{
    /* Stop warnings. */
    (void)pvParameters;

    /** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
    SCHEDULER IS STARTED. **/

    /* In case a task that has a secure context deletes itself, in which case
    the idle task is responsible for deleting the task's secure context, if
    any. */
    /* 当前的配置下，下面的接口无效 */
    portTASK_CALLS_SECURE_FUNCTIONS();

    for (;;)
    {
        /* See if any tasks have deleted themselves - if so then the idle task
        is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();

#if (configUSE_PREEMPTION == 0)
        {
            /* If we are not using preemption we keep forcing a task switch to
            see if any other task has become available.  If we are using
            preemption we don't need to do this as any task becoming available
            will automatically get the processor anyway. */
            taskYIELD();
        }
#endif /* configUSE_PREEMPTION */

#if ((configUSE_PREEMPTION == 1) && (configIDLE_SHOULD_YIELD == 1))
        {
            /* When using preemption tasks of equal priority will be
            timesliced.  If a task that is sharing the idle priority is ready
            to run then the idle task should yield before the end of the
            timeslice.

            A critical region is not required here as we are just reading from
            the list, and an occasional incorrect value will not matter.  If
            the ready list at the idle priority contains more than one task
            then a task other than the idle task is ready to execute. */
            /* configIDLE_SHOULD_YIELD的配置其实是让与idle同优先级的任务得到更多被调度的机会 */
            if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1)
            {
                taskYIELD();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */

#if (configUSE_IDLE_HOOK == 1)
        {
            extern void vApplicationIdleHook(void);

            /* Call the user defined function from within the idle task.  This
            allows the application designer to add background functionality
            without the overhead of a separate task.
            NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
            CALL A FUNCTION THAT MIGHT BLOCK. */
            /* 调用钩子函数 */
            vApplicationIdleHook();
        }
#endif /* configUSE_IDLE_HOOK */

/* This conditional compilation should use inequality to 0, not equality
to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
user defined low power mode	implementations require
configUSE_TICKLESS_IDLE to be set to a value other than 1. */
#if (configUSE_TICKLESS_IDLE != 0)
        {
            TickType_t xExpectedIdleTime;

            /* It is not desirable to suspend then resume the scheduler on
            each iteration of the idle task.  Therefore, a preliminary
            test of the expected idle time is performed without the
            scheduler suspended.  The result here is not necessarily
            valid. */
            xExpectedIdleTime = prvGetExpectedIdleTime();

            if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP)
            {
                vTaskSuspendAll();
                {
                    /* Now the scheduler is suspended, the expected idle
                    time can be sampled again, and this time its value can
                    be used. */
                    configASSERT(xNextTaskUnblockTime >= xTickCount);
                    xExpectedIdleTime = prvGetExpectedIdleTime();

                    /* Define the following macro to set xExpectedIdleTime to 0
                    if the application does not want
                    portSUPPRESS_TICKS_AND_SLEEP() to be called. */
                    configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING(xExpectedIdleTime);

                    if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP)
                    {
                        traceLOW_POWER_IDLE_BEGIN();
                        portSUPPRESS_TICKS_AND_SLEEP(xExpectedIdleTime);
                        traceLOW_POWER_IDLE_END();
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                (void)xTaskResumeAll();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
#endif /* configUSE_TICKLESS_IDLE */
    }
}
/*-----------------------------------------------------------*/

#if (configUSE_TICKLESS_IDLE != 0)

eSleepModeStatus eTaskConfirmSleepModeStatus(void)
{
    /* The idle task exists in addition to the application tasks. */
    const UBaseType_t uxNonApplicationTasks = 1;
    eSleepModeStatus eReturn = eStandardSleep;

    if (listCURRENT_LIST_LENGTH(&xPendingReadyList) != 0)
    {
        /* A task was made ready while the scheduler was suspended. */
        eReturn = eAbortSleep;
    }
    else if (xYieldPending != pdFALSE)
    {
        /* A yield was pended while the scheduler was suspended. */
        eReturn = eAbortSleep;
    }
    else
    {
        /* If all the tasks are in the suspended list (which might mean they
        have an infinite block time rather than actually being suspended)
        then it is safe to turn all clocks off and just wait for external
        interrupts. */
        if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) == (uxCurrentNumberOfTasks - uxNonApplicationTasks))
        {
            eReturn = eNoTasksWaitingTimeout;
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return eReturn;
}

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

#if (configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0)

void vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue)
{
    TCB_t *pxTCB;

    if (xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS)
    {
        pxTCB = prvGetTCBFromHandle(xTaskToSet);
        pxTCB->pvThreadLocalStoragePointers[xIndex] = pvValue;
    }
}

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
/*-----------------------------------------------------------*/

#if (configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0)

void *pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
    void *pvReturn = NULL;
    TCB_t *pxTCB;

    if (xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS)
    {
        pxTCB = prvGetTCBFromHandle(xTaskToQuery);
        pvReturn = pxTCB->pvThreadLocalStoragePointers[xIndex];
    }
    else
    {
        pvReturn = NULL;
    }

    return pvReturn;
}

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
/*-----------------------------------------------------------*/

#if (portUSING_MPU_WRAPPERS == 1)

void vTaskAllocateMPURegions(TaskHandle_t xTaskToModify, const MemoryRegion_t *const xRegions)
{
    TCB_t *pxTCB;

    /* If null is passed in here then we are modifying the MPU settings of
    the calling task. */
    pxTCB = prvGetTCBFromHandle(xTaskToModify);

    vPortStoreTaskMPUSettings(&(pxTCB->xMPUSettings), xRegions, NULL, 0);
}

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists(void)
{
    UBaseType_t uxPriority;

    for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++)
    {
        vListInitialise(&(pxReadyTasksLists[uxPriority]));
    }

    vListInitialise(&xDelayedTaskList1);
    vListInitialise(&xDelayedTaskList2);
    vListInitialise(&xPendingReadyList);

#if (INCLUDE_vTaskDelete == 1)
    {
        vListInitialise(&xTasksWaitingTermination);
    }
#endif /* INCLUDE_vTaskDelete */

#if (INCLUDE_vTaskSuspend == 1)
    {
        vListInitialise(&xSuspendedTaskList);
    }
#endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
    using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination(void)
{

    /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/

#if (INCLUDE_vTaskDelete == 1)
    {
        TCB_t *pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
        being called too often in the idle task. */
        /* uxDeletedTasksWaitingCleanUp表征了当前任务的自我删除 */
        while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U)
        {
            taskENTER_CRITICAL();
            {
                /* 如果任务自我删除，那么会增加到xTasksWaitingTermination链表。 */
                /* uxDeletedTasksWaitingCleanUp其实是表征了xTasksWaitingTermination链表中的有效元素数目 */
                pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xTasksWaitingTermination));
                /* 从状态相关链表中移除相应的任务信息 */
                (void)uxListRemove(&(pxTCB->xStateListItem));
                /* 当前的任务数以及等待清理的数目都相应减少1个 */
                --uxCurrentNumberOfTasks;
                --uxDeletedTasksWaitingCleanUp;
            }
            taskEXIT_CRITICAL();

            /* 真正的存储回收动作 */
            prvDeleteTCB(pxTCB);
        }
    }
#endif /* INCLUDE_vTaskDelete */
}
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

void vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
    TCB_t *pxTCB;

    /* xTask is NULL then get the state of the calling task. */
    pxTCB = prvGetTCBFromHandle(xTask);

    pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
    pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
    pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
    pxTaskStatus->pxStackBase = pxTCB->pxStack;
    pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;

#if (configUSE_MUTEXES == 1)
    {
        pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
    }
#else
    {
        pxTaskStatus->uxBasePriority = 0;
    }
#endif

#if (configGENERATE_RUN_TIME_STATS == 1)
    {
        pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
    }
#else
    {
        pxTaskStatus->ulRunTimeCounter = 0;
    }
#endif

    /* Obtaining the task state is a little fiddly, so is only done if the
    value of eState passed into this function is eInvalid - otherwise the
    state is just set to whatever is passed in. */
    if (eState != eInvalid)
    {
        if (pxTCB == pxCurrentTCB)
        {
            pxTaskStatus->eCurrentState = eRunning;
        }
        else
        {
            pxTaskStatus->eCurrentState = eState;

#if (INCLUDE_vTaskSuspend == 1)
            {
                /* If the task is in the suspended list then there is a
                chance it is actually just blocked indefinitely - so really
                it should be reported as being in the Blocked state. */
                if (eState == eSuspended)
                {
                    vTaskSuspendAll();
                    {
                        if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
                        {
                            pxTaskStatus->eCurrentState = eBlocked;
                        }
                    }
                    (void)xTaskResumeAll();
                }
            }
#endif /* INCLUDE_vTaskSuspend */
        }
    }
    else
    {
        pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
    }

    /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
    parameter is provided to allow it to be skipped. */
    if (xGetFreeStackSpace != pdFALSE)
    {
#if (portSTACK_GROWTH > 0)
        {
            pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxEndOfStack);
        }
#else
        {
            pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
        }
#endif
    }
    else
    {
        pxTaskStatus->usStackHighWaterMark = 0;
    }
}

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

static UBaseType_t prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState)
{
    configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
    UBaseType_t uxTask = 0;

    if (listCURRENT_LIST_LENGTH(pxList) > (UBaseType_t)0)
    {
        listGET_OWNER_OF_NEXT_ENTRY(pxFirstTCB, pxList);

        /* Populate an TaskStatus_t structure within the
        pxTaskStatusArray array for each task that is referenced from
        pxList.  See the definition of TaskStatus_t in task.h for the
        meaning of each TaskStatus_t structure member. */
        do
        {
            listGET_OWNER_OF_NEXT_ENTRY(pxNextTCB, pxList);
            vTaskGetInfo((TaskHandle_t)pxNextTCB, &(pxTaskStatusArray[uxTask]), pdTRUE, eState);
            uxTask++;
        } while (pxNextTCB != pxFirstTCB);
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return uxTask;
}

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if ((configUSE_TRACE_FACILITY == 1) || (INCLUDE_uxTaskGetStackHighWaterMark == 1))

static uint16_t prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte)
{
    uint32_t ulCount = 0U;

    while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE)
    {
        pucStackByte -= portSTACK_GROWTH;
        ulCount++;
    }

    ulCount /= (uint32_t)sizeof(StackType_t); /*lint !e961 Casting is not redundant on smaller architectures. */

    return (uint16_t)ulCount;
}

#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
/*-----------------------------------------------------------*/

#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)

UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)
{
    TCB_t *pxTCB;
    uint8_t *pucEndOfStack;
    UBaseType_t uxReturn;

    pxTCB = prvGetTCBFromHandle(xTask);

#if portSTACK_GROWTH < 0
    {
        pucEndOfStack = (uint8_t *)pxTCB->pxStack;
    }
#else
    {
        pucEndOfStack = (uint8_t *)pxTCB->pxEndOfStack;
    }
#endif

    uxReturn = (UBaseType_t)prvTaskCheckFreeStackSpace(pucEndOfStack);

    return uxReturn;
}

#endif /* INCLUDE_uxTaskGetStackHighWaterMark */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskDelete == 1)

static void prvDeleteTCB(TCB_t *pxTCB)
{
    /* This call is required specifically for the TriCore port.  It must be
    above the vPortFree() calls.  The call is also used by ports/demos that
    want to allocate and clean RAM statically. */
    portCLEAN_UP_TCB(pxTCB);

/* Free up the memory allocated by the scheduler for the task.  It is up
to the task to free any memory allocated at the application level. */
    /* 下面条件不成立 */
#if (configUSE_NEWLIB_REENTRANT == 1)
    {
        _reclaim_reent(&(pxTCB->xNewLib_reent));
    }
#endif /* configUSE_NEWLIB_REENTRANT */

    /* 下面条件不成立 */
#if ((configSUPPORT_DYNAMIC_ALLOCATION == 1) && (configSUPPORT_STATIC_ALLOCATION == 0) && (portUSING_MPU_WRAPPERS == 0))
    {
        /* The task can only have been allocated dynamically - free both
        the stack and TCB. */
        vPortFree(pxTCB->pxStack);
        vPortFree(pxTCB);
    }
    /*lint !e731 Macro has been consolidated for readability reasons. */
#elif (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0)
    {
        /* The task could have been allocated statically or dynamically, so
        check what was statically allocated before trying to free the
        memory. */
        if (pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB)
        {
            /* Both the stack and TCB were allocated dynamically, so both
            must be freed. */
            /* 如果是动态创建的模式，那么不仅要释放TCB占用的存储，还要释放堆栈空间 */
            vPortFree(pxTCB->pxStack);
            vPortFree(pxTCB);
        }
        else if (pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY)
        {
            /* Only the stack was statically allocated, so the TCB is the
            only memory that must be freed. */
            /* 如果是静态创建的模式，堆栈空间来自于应用软件，因此无法释放 */
            vPortFree(pxTCB);
        }
        else
        {
            /* Neither the stack nor the TCB were allocated dynamically, so
            nothing needs to be freed. */
            /* 如果全都是静态分配，那么不需要做存储的释放 */
            configASSERT(pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB);
            mtCOVERAGE_TEST_MARKER();
        }
    }
#endif                                                 /* configSUPPORT_DYNAMIC_ALLOCATION */
}

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime(void)
{
    TCB_t *pxTCB;

    /* 如果延迟任务链表不存在 */
    if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE)
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
        the maximum possible value so it is	extremely unlikely that the
        if( xTickCount >= xNextTaskUnblockTime ) test will pass until
        there is an item in the delayed list. */
        /* 从这一段注释看，任务执行的条件可能是xTickCount大于等于解锁时间点 */
        xNextTaskUnblockTime = portMAX_DELAY;
    }
    else
    {
        /* 如果延迟任务链表存在 */
        /* The new current delayed list is not empty, get the value of
        the item at the head of the delayed list.  This is the time at
        which the task at the head of the delayed list should be removed
        from the Blocked state. */
        /* 从延迟任务链表中获取它所归属的TCB信息 */
        (pxTCB) = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
        /* 通过前面的任务找到任务的状态链表元素，根据他的地址取出xItemValue信息 */
        /* 之前分析任务创建接口的时候知道，这个参数是用来实现链表排序的。 */
        /* 取到这个数据之后，赋值给xNextTaskUnblockTime */
        xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    }
}

/*-----------------------------------------------------------*/

#if ((INCLUDE_xTaskGetCurrentTaskHandle == 1) || (configUSE_MUTEXES == 1))

TaskHandle_t xTaskGetCurrentTaskHandle(void)
{
    TaskHandle_t xReturn;

    /* A critical section is not required as this is not called from
    an interrupt and the current TCB will always be the same for any
    individual execution thread. */
    xReturn = pxCurrentTCB;

    return xReturn;
}

#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
/*-----------------------------------------------------------*/

#if ((INCLUDE_xTaskGetSchedulerState == 1) || (configUSE_TIMERS == 1))

BaseType_t xTaskGetSchedulerState(void)
{
    BaseType_t xReturn;

    /* 如果调度器没有运行，那么调度器的状态是没启动 */
    if (xSchedulerRunning == pdFALSE)
    {
        xReturn = taskSCHEDULER_NOT_STARTED;
    }
    else
    {
        /* 如果调度器启动了，有2种状态 */
        if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
        {
            /* 一种状态是运行 */
            xReturn = taskSCHEDULER_RUNNING;
        }
        else
        {
            /* 另一种状态是挂起 */
            xReturn = taskSCHEDULER_SUSPENDED;
        }
    }

    return xReturn;
}

#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder)
{
    TCB_t *const pxMutexHolderTCB = (TCB_t *)pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

    /* If the mutex was given back by an interrupt while the queue was
    locked then the mutex holder might now be NULL.  _RB_ Is this still
    needed as interrupts can no longer use mutexes? */
    if (pxMutexHolder != NULL)
    {
        /* If the holder of the mutex has a priority below the priority of
        the task attempting to obtain the mutex then it will temporarily
        inherit the priority of the task attempting to obtain the mutex. */
        if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority)
        {
            /* Adjust the mutex holder state to account for its new
            priority.  Only reset the event list item value if the value is
            not being used for anything else. */
            if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL)
            {
                listSET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)pxCurrentTCB->uxPriority); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* If the task being modified is in the ready state it will need
            to be moved into a new list. */
            if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxMutexHolderTCB->uxPriority]), &(pxMutexHolderTCB->xStateListItem)) != pdFALSE)
            {
                if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) == (UBaseType_t)0)
                {
                    taskRESET_READY_PRIORITY(pxMutexHolderTCB->uxPriority);
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                /* Inherit the priority before being moved into the new list. */
                pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
                prvAddTaskToReadyList(pxMutexHolderTCB);
            }
            else
            {
                /* Just inherit the priority. */
                pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
            }

            traceTASK_PRIORITY_INHERIT(pxMutexHolderTCB, pxCurrentTCB->uxPriority);

            /* Inheritance occurred. */
            xReturn = pdTRUE;
        }
        else
        {
            if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority)
            {
                /* The base priority of the mutex holder is lower than the
                priority of the task attempting to take the mutex, but the
                current priority of the mutex holder is not lower than the
                priority of the task attempting to take the mutex.
                Therefore the mutex holder must have already inherited a
                priority, but inheritance would have occurred if that had
                not been the case. */
                xReturn = pdTRUE;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder)
{
    TCB_t *const pxTCB = (TCB_t *)pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

    if (pxMutexHolder != NULL)
    {
        /* A task can only have an inherited priority if it holds the mutex.
        If the mutex is held by a task then it cannot be given from an
        interrupt, and if a mutex is given by the holding task then it must
        be the running state task. */
        configASSERT(pxTCB == pxCurrentTCB);
        configASSERT(pxTCB->uxMutexesHeld);
        (pxTCB->uxMutexesHeld)--;

        /* Has the holder of the mutex inherited the priority of another
        task? */
        if (pxTCB->uxPriority != pxTCB->uxBasePriority)
        {
            /* Only disinherit if no other mutexes are held. */
            if (pxTCB->uxMutexesHeld == (UBaseType_t)0)
            {
                /* A task can only have an inherited priority if it holds
                the mutex.  If the mutex is held by a task then it cannot be
                given from an interrupt, and if a mutex is given by the
                holding task then it must be the running state task.  Remove
                the holding task from the ready list. */
                if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
                {
                    taskRESET_READY_PRIORITY(pxTCB->uxPriority);
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                /* Disinherit the priority before adding the task into the
                new	ready list. */
                traceTASK_PRIORITY_DISINHERIT(pxTCB, pxTCB->uxBasePriority);
                pxTCB->uxPriority = pxTCB->uxBasePriority;

                /* Reset the event list item value.  It cannot be in use for
                any other purpose if this task is running, and it must be
                running to give back the mutex. */
                listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)pxTCB->uxPriority); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                prvAddTaskToReadyList(pxTCB);

                /* Return true to indicate that a context switch is required.
                This is only actually required in the corner case whereby
                multiple mutexes were held and the mutexes were given back
                in an order different to that in which they were taken.
                If a context switch did not occur when the first mutex was
                returned, even if a task was waiting on it, then a context
                switch should occur when the last mutex is returned whether
                a task is waiting on it or not. */
                xReturn = pdTRUE;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

void vTaskPriorityDisinheritAfterTimeout(TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
    TCB_t *const pxTCB = (TCB_t *)pxMutexHolder;
    UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
    const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;

    if (pxMutexHolder != NULL)
    {
        /* If pxMutexHolder is not NULL then the holder must hold at least
        one mutex. */
        configASSERT(pxTCB->uxMutexesHeld);

        /* Determine the priority to which the priority of the task that
        holds the mutex should be set.  This will be the greater of the
        holding task's base priority and the priority of the highest
        priority task that is waiting to obtain the mutex. */
        if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask)
        {
            uxPriorityToUse = uxHighestPriorityWaitingTask;
        }
        else
        {
            uxPriorityToUse = pxTCB->uxBasePriority;
        }

        /* Does the priority need to change? */
        if (pxTCB->uxPriority != uxPriorityToUse)
        {
            /* Only disinherit if no other mutexes are held.  This is a
            simplification in the priority inheritance implementation.  If
            the task that holds the mutex is also holding other mutexes then
            the other mutexes may have caused the priority inheritance. */
            if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld)
            {
                /* If a task has timed out because it already holds the
                mutex it was trying to obtain then it cannot of inherited
                its own priority. */
                configASSERT(pxTCB != pxCurrentTCB);

                /* Disinherit the priority, remembering the previous
                priority to facilitate determining the subject task's
                state. */
                traceTASK_PRIORITY_DISINHERIT(pxTCB, pxTCB->uxBasePriority);
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
                pxTCB->uxPriority = uxPriorityToUse;

                /* Only reset the event list item value if the value is not
                being used for anything else. */
                if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL)
                {
                    listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)uxPriorityToUse); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the running task is not the task that holds the mutex
                then the task that holds the mutex could be in either the
                Ready, Blocked or Suspended states.  Only remove the task
                from its current state list if it is in the Ready state as
                the task's priority is going to change and there is one
                Ready list per priority. */
                if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), &(pxTCB->xStateListItem)) != pdFALSE)
                {
                    if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
                    {
                        taskRESET_READY_PRIORITY(pxTCB->uxPriority);
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList(pxTCB);
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if (portCRITICAL_NESTING_IN_TCB == 1)

void vTaskEnterCritical(void)
{
    portDISABLE_INTERRUPTS();

    /* 可以用调度器状态获取函数代替提高可读性，但是效率不高 */
    if (xSchedulerRunning != pdFALSE)
    {
        (pxCurrentTCB->uxCriticalNesting)++;

        /* This is not the interrupt safe version of the enter critical
        function so	assert() if it is being called from an interrupt
        context.  Only API functions that end in "FromISR" can be used in an
        interrupt.  Only assert if the critical nesting count is 1 to
        protect against recursive calls if the assert function also uses a
        critical section. */
        if (pxCurrentTCB->uxCriticalNesting == 1)
        {
            portASSERT_IF_IN_ISR();
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}

#endif /* portCRITICAL_NESTING_IN_TCB */
/*-----------------------------------------------------------*/

#if (portCRITICAL_NESTING_IN_TCB == 1)

void vTaskExitCritical(void)
{
    /* 可以用调度器状态获取函数代替提高可读性，但是效率不高 */
    if (xSchedulerRunning != pdFALSE)
    {
        if (pxCurrentTCB->uxCriticalNesting > 0U)
        {
            (pxCurrentTCB->uxCriticalNesting)--;

            if (pxCurrentTCB->uxCriticalNesting == 0U)
            {
                portENABLE_INTERRUPTS();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}

#endif /* portCRITICAL_NESTING_IN_TCB */
/*-----------------------------------------------------------*/

#if ((configUSE_TRACE_FACILITY == 1) && (configUSE_STATS_FORMATTING_FUNCTIONS > 0))

static char *prvWriteNameToBuffer(char *pcBuffer, const char *pcTaskName)
{
    size_t x;

    /* Start by copying the entire string. */
    strcpy(pcBuffer, pcTaskName);

    /* Pad the end of the string with spaces to ensure columns line up when
    printed out. */
    for (x = strlen(pcBuffer); x < (size_t)(configMAX_TASK_NAME_LEN - 1); x++)
    {
        pcBuffer[x] = ' ';
    }

    /* Terminate. */
    pcBuffer[x] = 0x00;

    /* Return the new end of string. */
    return &(pcBuffer[x]);
}

#endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
/*-----------------------------------------------------------*/

#if ((configUSE_TRACE_FACILITY == 1) && (configUSE_STATS_FORMATTING_FUNCTIONS > 0) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))

void vTaskList(char *pcWriteBuffer)
{
    TaskStatus_t *pxTaskStatusArray;
    volatile UBaseType_t uxArraySize, x;
    char cStatus;

    /*
     * PLEASE NOTE:
     *
     * This function is provided for convenience only, and is used by many
     * of the demo applications.  Do not consider it to be part of the
     * scheduler.
     *
     * vTaskList() calls uxTaskGetSystemState(), then formats part of the
     * uxTaskGetSystemState() output into a human readable table that
     * displays task names, states and stack usage.
     *
     * vTaskList() has a dependency on the sprintf() C library function that
     * might bloat the code size, use a lot of stack, and provide different
     * results on different platforms.  An alternative, tiny, third party,
     * and limited functionality implementation of sprintf() is provided in
     * many of the FreeRTOS/Demo sub-directories in a file called
     * printf-stdarg.c (note printf-stdarg.c does not provide a full
     * snprintf() implementation!).
     *
     * It is recommended that production systems call uxTaskGetSystemState()
     * directly to get access to raw stats data, rather than indirectly
     * through a call to vTaskList().
     */

    /* Make sure the write buffer does not contain a string. */
    *pcWriteBuffer = 0x00;

    /* Take a snapshot of the number of tasks in case it changes while this
    function is executing. */
    uxArraySize = uxCurrentNumberOfTasks;

    /* Allocate an array index for each task.  NOTE!  if
    configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
    equate to NULL. */
    pxTaskStatusArray = pvPortMalloc(uxCurrentNumberOfTasks * sizeof(TaskStatus_t));

    if (pxTaskStatusArray != NULL)
    {
        /* Generate the (binary) data. */
        uxArraySize = uxTaskGetSystemState(pxTaskStatusArray, uxArraySize, NULL);

        /* Create a human readable table from the binary data. */
        for (x = 0; x < uxArraySize; x++)
        {
            switch (pxTaskStatusArray[x].eCurrentState)
            {
            case eRunning:
                cStatus = tskRUNNING_CHAR;
                break;

            case eReady:
                cStatus = tskREADY_CHAR;
                break;

            case eBlocked:
                cStatus = tskBLOCKED_CHAR;
                break;

            case eSuspended:
                cStatus = tskSUSPENDED_CHAR;
                break;

            case eDeleted:
                cStatus = tskDELETED_CHAR;
                break;

            default: /* Should not get here, but it is included
                     to prevent static checking errors. */
                cStatus = 0x00;
                break;
            }

            /* Write the task name to the string, padding with spaces so it
            can be printed in tabular form more easily. */
            pcWriteBuffer = prvWriteNameToBuffer(pcWriteBuffer, pxTaskStatusArray[x].pcTaskName);

            /* Write the rest of the string. */
            sprintf(pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, (unsigned int)pxTaskStatusArray[x].uxCurrentPriority, (unsigned int)pxTaskStatusArray[x].usStackHighWaterMark, (unsigned int)pxTaskStatusArray[x].xTaskNumber);
            pcWriteBuffer += strlen(pcWriteBuffer);
        }

        /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
        is 0 then vPortFree() will be #defined to nothing. */
        vPortFree(pxTaskStatusArray);
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}

#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*----------------------------------------------------------*/

#if ((configGENERATE_RUN_TIME_STATS == 1) && (configUSE_STATS_FORMATTING_FUNCTIONS > 0) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))

void vTaskGetRunTimeStats(char *pcWriteBuffer)
{
    TaskStatus_t *pxTaskStatusArray;
    volatile UBaseType_t uxArraySize, x;
    uint32_t ulTotalTime, ulStatsAsPercentage;

#if (configUSE_TRACE_FACILITY != 1)
    {
#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
    }
#endif

    /*
     * PLEASE NOTE:
     *
     * This function is provided for convenience only, and is used by many
     * of the demo applications.  Do not consider it to be part of the
     * scheduler.
     *
     * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
     * of the uxTaskGetSystemState() output into a human readable table that
     * displays the amount of time each task has spent in the Running state
     * in both absolute and percentage terms.
     *
     * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
     * function that might bloat the code size, use a lot of stack, and
     * provide different results on different platforms.  An alternative,
     * tiny, third party, and limited functionality implementation of
     * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
     * a file called printf-stdarg.c (note printf-stdarg.c does not provide
     * a full snprintf() implementation!).
     *
     * It is recommended that production systems call uxTaskGetSystemState()
     * directly to get access to raw stats data, rather than indirectly
     * through a call to vTaskGetRunTimeStats().
     */

    /* Make sure the write buffer does not contain a string. */
    *pcWriteBuffer = 0x00;

    /* Take a snapshot of the number of tasks in case it changes while this
    function is executing. */
    uxArraySize = uxCurrentNumberOfTasks;

    /* Allocate an array index for each task.  NOTE!  If
    configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
    equate to NULL. */
    pxTaskStatusArray = pvPortMalloc(uxCurrentNumberOfTasks * sizeof(TaskStatus_t));

    if (pxTaskStatusArray != NULL)
    {
        /* Generate the (binary) data. */
        uxArraySize = uxTaskGetSystemState(pxTaskStatusArray, uxArraySize, &ulTotalTime);

        /* For percentage calculations. */
        ulTotalTime /= 100UL;

        /* Avoid divide by zero errors. */
        if (ulTotalTime > 0)
        {
            /* Create a human readable table from the binary data. */
            for (x = 0; x < uxArraySize; x++)
            {
                /* What percentage of the total run time has the task used?
                This will always be rounded down to the nearest integer.
                ulTotalRunTimeDiv100 has already been divided by 100. */
                ulStatsAsPercentage = pxTaskStatusArray[x].ulRunTimeCounter / ulTotalTime;

                /* Write the task name to the string, padding with
                spaces so it can be printed in tabular form more
                easily. */
                pcWriteBuffer = prvWriteNameToBuffer(pcWriteBuffer, pxTaskStatusArray[x].pcTaskName);

                if (ulStatsAsPercentage > 0UL)
                {
#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                    {
                        sprintf(pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[x].ulRunTimeCounter, ulStatsAsPercentage);
                    }
#else
                    {
                        /* sizeof( int ) == sizeof( long ) so a smaller
                        printf() library can be used. */
                        sprintf(pcWriteBuffer, "\t%u\t\t%u%%\r\n", (unsigned int)pxTaskStatusArray[x].ulRunTimeCounter, (unsigned int)ulStatsAsPercentage);
                    }
#endif
                }
                else
                {
/* If the percentage is zero here then the task has
consumed less than 1% of the total run time. */
#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                    {
                        sprintf(pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[x].ulRunTimeCounter);
                    }
#else
                    {
                        /* sizeof( int ) == sizeof( long ) so a smaller
                        printf() library can be used. */
                        sprintf(pcWriteBuffer, "\t%u\t\t<1%%\r\n", (unsigned int)pxTaskStatusArray[x].ulRunTimeCounter);
                    }
#endif
                }

                pcWriteBuffer += strlen(pcWriteBuffer);
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
        is 0 then vPortFree() will be #defined to nothing. */
        vPortFree(pxTaskStatusArray);
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue(void)
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE(&(pxCurrentTCB->xEventListItem));

    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xEventListItem), ((TickType_t)configMAX_PRIORITIES - (TickType_t)pxCurrentTCB->uxPriority)); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

void *pvTaskIncrementMutexHeldCount(void)
{
    /* If xSemaphoreCreateMutex() is called before any tasks have been created
    then pxCurrentTCB will be NULL. */
    if (pxCurrentTCB != NULL)
    {
        (pxCurrentTCB->uxMutexesHeld)++;
    }

    return pxCurrentTCB;
}

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
    uint32_t ulReturn;

    taskENTER_CRITICAL();
    {
        /* Only block if the notification count is not already non-zero. */
        if (pxCurrentTCB->ulNotifiedValue == 0UL)
        {
            /* Mark this task as waiting for a notification. */
            pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;

            if (xTicksToWait > (TickType_t)0)
            {
                prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
                traceTASK_NOTIFY_TAKE_BLOCK();

                /* All ports are written to allow a yield in a critical
                section (some will yield immediately, others wait until the
                critical section exits) - but it is not something that
                application code should ever do. */
                portYIELD_WITHIN_API();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();

    taskENTER_CRITICAL();
    {
        traceTASK_NOTIFY_TAKE();
        ulReturn = pxCurrentTCB->ulNotifiedValue;

        if (ulReturn != 0UL)
        {
            if (xClearCountOnExit != pdFALSE)
            {
                pxCurrentTCB->ulNotifiedValue = 0UL;
            }
            else
            {
                pxCurrentTCB->ulNotifiedValue = ulReturn - (uint32_t)1;
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    }
    taskEXIT_CRITICAL();

    return ulReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

BaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    {
        /* Only block if a notification is not already pending. */
        if (pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED)
        {
            /* Clear bits in the task's notification value as bits may get
            set	by the notifying task or interrupt.  This can be used to
            clear the value to zero. */
            pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;

            /* Mark this task as waiting for a notification. */
            pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;

            if (xTicksToWait > (TickType_t)0)
            {
                prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
                traceTASK_NOTIFY_WAIT_BLOCK();

                /* All ports are written to allow a yield in a critical
                section (some will yield immediately, others wait until the
                critical section exits) - but it is not something that
                application code should ever do. */
                portYIELD_WITHIN_API();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();

    taskENTER_CRITICAL();
    {
        traceTASK_NOTIFY_WAIT();

        if (pulNotificationValue != NULL)
        {
            /* Output the current notification value, which may or may not
            have changed. */
            *pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
        }

        /* If ucNotifyValue is set then either the task never entered the
        blocked state (because a notification was already pending) or the
        task unblocked because of a notification.  Otherwise the task
        unblocked because of a timeout. */
        if (pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED)
        {
            /* A notification was not received. */
            xReturn = pdFALSE;
        }
        else
        {
            /* A notification was already pending or a notification was
            received while the task was waiting. */
            pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
            xReturn = pdTRUE;
        }

        pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    }
    taskEXIT_CRITICAL();

    return xReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

BaseType_t xTaskGenericNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue)
{
    TCB_t *pxTCB;
    BaseType_t xReturn = pdPASS;
    uint8_t ucOriginalNotifyState;

    configASSERT(xTaskToNotify);
    pxTCB = (TCB_t *)xTaskToNotify;

    taskENTER_CRITICAL();
    {
        if (pulPreviousNotificationValue != NULL)
        {
            *pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
        }

        ucOriginalNotifyState = pxTCB->ucNotifyState;

        pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

        switch (eAction)
        {
        case eSetBits:
            pxTCB->ulNotifiedValue |= ulValue;
            break;

        case eIncrement:
            (pxTCB->ulNotifiedValue)++;
            break;

        case eSetValueWithOverwrite:
            pxTCB->ulNotifiedValue = ulValue;
            break;

        case eSetValueWithoutOverwrite:
            if (ucOriginalNotifyState != taskNOTIFICATION_RECEIVED)
            {
                pxTCB->ulNotifiedValue = ulValue;
            }
            else
            {
                /* The value could not be written to the task. */
                xReturn = pdFAIL;
            }
            break;

        case eNoAction:
            /* The task is being notified without its notify value being
            updated. */
            break;
        }

        traceTASK_NOTIFY();

        /* If the task is in the blocked state specifically to wait for a
        notification then unblock it now. */
        if (ucOriginalNotifyState == taskWAITING_NOTIFICATION)
        {
            (void)uxListRemove(&(pxTCB->xStateListItem));
            prvAddTaskToReadyList(pxTCB);

            /* The task should not have been on an event list. */
            configASSERT(listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL);

#if (configUSE_TICKLESS_IDLE != 0)
            {
                /* If a task is blocked waiting for a notification then
                xNextTaskUnblockTime might be set to the blocked task's time
                out time.  If the task is unblocked for a reason other than
                a timeout xNextTaskUnblockTime is normally left unchanged,
                because it will automatically get reset to a new value when
                the tick count equals xNextTaskUnblockTime.  However if
                tickless idling is used it might be more important to enter
                sleep mode at the earliest possible time - so reset
                xNextTaskUnblockTime here to ensure it is updated at the
                earliest possible time. */
                prvResetNextTaskUnblockTime();
            }
#endif

            if (pxTCB->uxPriority > pxCurrentTCB->uxPriority)
            {
                /* The notified task has a priority above the currently
                executing task so a yield is required. */
                taskYIELD_IF_USING_PREEMPTION();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();

    return xReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

BaseType_t xTaskGenericNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken)
{
    TCB_t *pxTCB;
    uint8_t ucOriginalNotifyState;
    BaseType_t xReturn = pdPASS;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT(xTaskToNotify);

    /* RTOS ports that support interrupt nesting have the concept of a
    maximum	system call (or maximum API call) interrupt priority.
    Interrupts that are	above the maximum system call priority are keep
    permanently enabled, even when the RTOS kernel is in a critical section,
    but cannot make any calls to FreeRTOS API functions.  If configASSERT()
    is defined in FreeRTOSConfig.h then
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
    failure if a FreeRTOS API function is called from an interrupt that has
    been assigned a priority above the configured maximum system call
    priority.  Only FreeRTOS functions that end in FromISR can be called
    from interrupts	that have been assigned a priority at or (logically)
    below the maximum system call interrupt priority.  FreeRTOS maintains a
    separate interrupt safe API to ensure interrupt entry is as fast and as
    simple as possible.  More information (albeit Cortex-M specific) is
    provided on the following link:
    http://www.freertos.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    pxTCB = (TCB_t *)xTaskToNotify;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if (pulPreviousNotificationValue != NULL)
        {
            *pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
        }

        ucOriginalNotifyState = pxTCB->ucNotifyState;
        pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

        switch (eAction)
        {
        case eSetBits:
            pxTCB->ulNotifiedValue |= ulValue;
            break;

        case eIncrement:
            (pxTCB->ulNotifiedValue)++;
            break;

        case eSetValueWithOverwrite:
            pxTCB->ulNotifiedValue = ulValue;
            break;

        case eSetValueWithoutOverwrite:
            if (ucOriginalNotifyState != taskNOTIFICATION_RECEIVED)
            {
                pxTCB->ulNotifiedValue = ulValue;
            }
            else
            {
                /* The value could not be written to the task. */
                xReturn = pdFAIL;
            }
            break;

        case eNoAction:
            /* The task is being notified without its notify value being
            updated. */
            break;
        }

        traceTASK_NOTIFY_FROM_ISR();

        /* If the task is in the blocked state specifically to wait for a
        notification then unblock it now. */
        if (ucOriginalNotifyState == taskWAITING_NOTIFICATION)
        {
            /* The task should not have been on an event list. */
            configASSERT(listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL);

            if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
            {
                (void)uxListRemove(&(pxTCB->xStateListItem));
                prvAddTaskToReadyList(pxTCB);
            }
            else
            {
                /* The delayed and ready lists cannot be accessed, so hold
                this task pending until the scheduler is resumed. */
                vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
            }

            if (pxTCB->uxPriority > pxCurrentTCB->uxPriority)
            {
                /* The notified task has a priority above the currently
                executing task so a yield is required. */
                if (pxHigherPriorityTaskWoken != NULL)
                {
                    *pxHigherPriorityTaskWoken = pdTRUE;
                }
                else
                {
                    /* Mark that a yield is pending in case the user is not
                    using the "xHigherPriorityTaskWoken" parameter to an ISR
                    safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);

    return xReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken)
{
    TCB_t *pxTCB;
    uint8_t ucOriginalNotifyState;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT(xTaskToNotify);

    /* RTOS ports that support interrupt nesting have the concept of a
    maximum	system call (or maximum API call) interrupt priority.
    Interrupts that are	above the maximum system call priority are keep
    permanently enabled, even when the RTOS kernel is in a critical section,
    but cannot make any calls to FreeRTOS API functions.  If configASSERT()
    is defined in FreeRTOSConfig.h then
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
    failure if a FreeRTOS API function is called from an interrupt that has
    been assigned a priority above the configured maximum system call
    priority.  Only FreeRTOS functions that end in FromISR can be called
    from interrupts	that have been assigned a priority at or (logically)
    below the maximum system call interrupt priority.  FreeRTOS maintains a
    separate interrupt safe API to ensure interrupt entry is as fast and as
    simple as possible.  More information (albeit Cortex-M specific) is
    provided on the following link:
    http://www.freertos.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    pxTCB = (TCB_t *)xTaskToNotify;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        ucOriginalNotifyState = pxTCB->ucNotifyState;
        pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

        /* 'Giving' is equivalent to incrementing a count in a counting
        semaphore. */
        (pxTCB->ulNotifiedValue)++;

        traceTASK_NOTIFY_GIVE_FROM_ISR();

        /* If the task is in the blocked state specifically to wait for a
        notification then unblock it now. */
        if (ucOriginalNotifyState == taskWAITING_NOTIFICATION)
        {
            /* The task should not have been on an event list. */
            configASSERT(listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL);

            if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
            {
                (void)uxListRemove(&(pxTCB->xStateListItem));
                prvAddTaskToReadyList(pxTCB);
            }
            else
            {
                /* The delayed and ready lists cannot be accessed, so hold
                this task pending until the scheduler is resumed. */
                vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
            }

            if (pxTCB->uxPriority > pxCurrentTCB->uxPriority)
            {
                /* The notified task has a priority above the currently
                executing task so a yield is required. */
                if (pxHigherPriorityTaskWoken != NULL)
                {
                    *pxHigherPriorityTaskWoken = pdTRUE;
                }
                else
                {
                    /* Mark that a yield is pending in case the user is not
                    using the "xHigherPriorityTaskWoken" parameter in an ISR
                    safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
}

#endif /* configUSE_TASK_NOTIFICATIONS */

/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

BaseType_t xTaskNotifyStateClear(TaskHandle_t xTask)
{
    TCB_t *pxTCB;
    BaseType_t xReturn;

    /* If null is passed in here then it is the calling task that is having
    its notification state cleared. */
    pxTCB = prvGetTCBFromHandle(xTask);

    taskENTER_CRITICAL();
    {
        if (pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED)
        {
            pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
            xReturn = pdPASS;
        }
        else
        {
            xReturn = pdFAIL;
        }
    }
    taskEXIT_CRITICAL();

    return xReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;

    /* 下面的条件不成立 */
#if (INCLUDE_xTaskAbortDelay == 1)
    {
        /* About to enter a delayed list, so ensure the ucDelayAborted flag is
        reset to pdFALSE so it can be detected as having been set to pdTRUE
        when the task leaves the Blocked state. */
        pxCurrentTCB->ucDelayAborted = pdFALSE;
    }
#endif

    /* Remove the task from the ready list before adding it to the blocked list
    as the same list item is used for both lists. */
    /* 首先把当前任务从就绪任务链表中移除，然后看看就绪链任务链表是否还有任务。 */
    /* 如果就绪任务链表中没有任务了，那么执行下面的操作 */
    if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0)
    {
        /* The current task must be in a ready list, so there is no need to
        check, and the port reset macro can be called directly. */
        /* 下面的接口之前是分析过的，结合上面的条件，这里做的处理是：如果当前任务
         * 的优先级就绪任务链表没有任务了，需要标注一下这个优先级中不再有就绪任务 */
        portRESET_READY_PRIORITY(pxCurrentTCB->uxPriority, uxTopReadyPriority);
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* 如下条件成立 */
#if (INCLUDE_vTaskSuspend == 1)
    {
        /* 如果设置的等待时间是一个极大值或者指示可以无限时间阻塞 */
        if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE))
        {
            /* Add the task to the suspended task list instead of a delayed task
            list to ensure it is not woken by a timing event.  It will block
            indefinitely. */
            /* 把当前的任务增加到挂起任务链表中的最后位置 */
            vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
        }
        else
        {
            /* Calculate the time at which the task should be woken if the event
            does not occur.  This may overflow but this doesn't matter, the
            kernel will manage it correctly. */
            /* 唤醒时间是当前tick数值加上等待事件 */
            xTimeToWake = xConstTickCount + xTicksToWait;

            /* The list item will be inserted in wake time order. */
            /* 当前任务的xStateListItem设置为唤醒计数，这样之前看到的延迟调度模型就建立了 */
            listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);

            /* 唤醒时间如果小于当前的tick，那么发生了溢出 */
            if (xTimeToWake < xConstTickCount)
            {
                /* Wake time has overflowed.  Place this item in the overflow
                list. */
                /* 溢出之后的处理，跟普通的delayed task放在一起排序肯定异常，因此增加
                 * 这样一个溢出的delayed task，这样之前不清楚的点又算是清晰了。其实delayed
                 * task链表应该使用频率不高。 */
                /* 我在思考这样的问题的时候可能会考虑给每一个任务设置一个减数计数器来进行
                 * “定时”。这样，可以少一个delayed task链表。但是，每次tick都要更新所有链
                 * 表元素的数值，可能会多一些计算量。 */
                vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                is used. */
                /* 没有溢出的时候，插入到delayed链表之中，这个过程中链表的元素其实做了排序 */
                vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));

                /* If the task entering the blocked state was placed at the
                head of the list of blocked tasks then xNextTaskUnblockTime
                needs to be updated too. */
                /* 这样，xNextTaskUnblockTime的含义也很明确了，就是最近一次的唤醒tick点 */
                if (xTimeToWake < xNextTaskUnblockTime)
                {
                    xNextTaskUnblockTime = xTimeToWake;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
    }
#else  /* INCLUDE_vTaskSuspend */
    /* 后面这部分无效，这次暂且不做分析了 */
    {
        /* Calculate the time at which the task should be woken if the event
        does not occur.  This may overflow but this doesn't matter, the kernel
        will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);

        if (xTimeToWake < xConstTickCount)
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));

            /* If the task entering the blocked state was placed at the head of the
            list of blocked tasks then xNextTaskUnblockTime needs to be updated
            too. */
            if (xTimeToWake < xNextTaskUnblockTime)
            {
                xNextTaskUnblockTime = xTimeToWake;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        (void)xCanBlockIndefinitely;
    }
#endif /* INCLUDE_vTaskSuspend */
}

/* Code below here allows additional code to be inserted into this source file,
especially where access to file scope functions and data is needed (for example
when performing module tests). */

#ifdef FREERTOS_MODULE_TEST
#include "tasks_test_access_functions.h"
#endif

#if (configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1)

#include "freertos_tasks_c_additions.h"

static void freertos_tasks_c_additions_init(void)
{
#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
    FREERTOS_TASKS_C_ADDITIONS_INIT();
#endif
}

#endif
